<html>

<head>
<title>r010101: Do Programs Teach Algorithms?</title>
<!--$$Header: /OrcmidCompagno/readings/R010101.htm 17    03-05-25 10:50 Orcmid $-->
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>

<body bgcolor="#FFFFFF" link="#0000FF" vlink="#800080" alink="#FF0000" text="#000080">

<font face="Arial, Microsoft Sans Serif, Helvetica, Geneva, Swiss, Sans Serif">
<table border="0" width="100%" height="3">
  <tr>
    
    <td width="12%" height="6">

<font face="Arial, Microsoft Sans Serif, Helvetica, Geneva, Swiss, Sans Serif">
	<!--webbot bot="Include" U-Include="../../construction/templates/00/c000007b.htm"
      TAG="BODY" startspan -->
<a href="../../bib" target="_top">
<img border="0" src="../../images/F23xy102-2023-09-05-1601-MyBookCase.png" width="160" height="209" alt="Shelves of Technical Books" longdesc="2023-09-05 Photograph of shelves of one of Orcmid's bookcases"></a><a href="http://orcmid.com" target="_top">
<!-- Included from construction/templates/00/c000007b.htm of 2023-09-07-19:38Z --></a>
<!--webbot bot="Include" i-checksum="58372" endspan --></font></td>
    
    <td width="74%" height="6">
      <p align="center"><strong><font color="#990033">Bibliography 
		Readings/Notes<br>
		<i><font size="5">Do Programs Teach Algorithms?</font></i></font></strong></p>
    </td>
    
    <td width="13%" height="6">

<font face="Arial, Microsoft Sans Serif, Helvetica, Geneva, Swiss, Sans Serif">
      <p align="right"><b><code><a href="../../" target="_top">orcmid.github.io</a>&gt;<br>
		<a href="../" target="_top">bib</a>&gt;<a href="./">2001</a>&gt;</code></b></p>
		<div align="right">
			<!--webbot bot="Include" U-Include="../../construction/templates/00/c000006b1.htm" TAG="BODY" startspan -->
		
		<table border="0" width="24%" style="border-collapse: collapse" id="ClustrMap">
		<caption align="bottom" valign="bottom"><small><small>
				<a href="../../construction/templates/00/c000006.htm">visits to <b>Orcmid on GitHub</b></a></small></small></caption>
			<tr>
				<td>
				<p align="center">
			<small>
			<font color="#707070" face="Arial, Microsoft Sans Serif, Helvetica, Geneva, Swiss, Sans Serif">

				<a href="https://clustrmaps.com/site/1bw9w" title="Visit tracker"><img src="//www.clustrmaps.com/map_v2.png?d=3-2eQV4fOuelVHp_YtztZ0hl9Uj4ei9zLKw_nRgCgyM&cl=ffffff"></a>
				</font></small></td>
			</tr>
			<!-- Inserted from orcmid.github.io/construction/templates/00/c000006c1.htm of 2023-09-10T18:34Z -->
		</table>
	
	<!--webbot bot="Include" i-checksum="52261" endspan --></div>
      <p align="right"><code><b><a href="r010101.htm">r010101</a></b></code><b><code>&gt;</code></b><br>
      <small><small><a href="#v0.3.0">0.3.0</a> 
		<!--webbot bot="Timestamp" S-Type="REGENERATED" S-Format="%Y-%m-%d %H:%M" startspan -->2023-11-17 18:47<!--webbot bot="Timestamp" i-checksum="25737" endspan --></small></small></font><small>
      </small></p>
      </td>
    
  </tr>
</table>

<hr color="#990033">

</font>


    <dl>
      <dd><b><a name="review">Sedgewick, Robert</a>.&nbsp; <i>
		<a href="../compsci.htm#Sedgewick1989">Algorithms</a></i>.&nbsp; Second edition.&nbsp; Addison-Wesley (Reading, 
		MA: 1983, 1988).&nbsp; 1989 reprint with authors corrections.&nbsp; ISBN 
		0-201-06673-4.</b></dd>
      <dd><font size="-1">
        &nbsp;&nbsp;&nbsp;&nbsp; This book presents an interesting challenge.&nbsp; 
		It talks about algorithms but it does not show any algorithms, nor does 
		it define algorithm as anything more than a &quot;problem-solving method 
		suitable for implementation as computer programs. [p.4]&quot;&nbsp; Instead, 
		it exhibits programs which are the implementations of algorithms and 
		discusses them as if the algorithm is apparent.&nbsp; The reader is left 
		with the challenge of learning to discriminate between what is essential 
		about an algorithm, and how to preserve that in an implementation, 
		versus what is inessential to the algorithm and introduced on account of 
		the implementation and the use of particular programming tools.&nbsp; I 
		am concerned that this approach, while well-motivated, is not 
		successful.&nbsp; My evidence is in the many criticisms of this and 
		later editions of the book that focus on the choice of programming 
		language and that object to stylistic matters in the use of the chosen 
		language to present the algorithms.&nbsp; This places too much emphasis 
		on code.&nbsp;&nbsp; Although code rules these days, I remain 
		unconvinced that this simplification is a good thing.&nbsp; For me, one 
		of the great insights in development of software is identification of 
		layers of abstraction for conquering the organization of complex 
		application programs.&nbsp; Separating design, algorithm and 
		implementation is a critical first step toward that mastery.&nbsp;<br>
        &nbsp;&nbsp;&nbsp;&nbsp; Meanwhile, <i>Algorithms</i> serves up a handy 
		set of recipes for a variety of basic computing situations.&nbsp; The 45 
		sections cover fundamental methods of widespread application in 
		computing and software development. The presentations are 
		straightforward and illuminating.&nbsp; The compilation bears 
		re-examination every time one sits down to identify key methods for a 
		new application.&nbsp; I recommend supplementing this material with the 
		practical methods of <i>Software Tools</i> and the introspective 
		explorations of <i>Programming Pearls</i>.&nbsp; Most of all I encourage 
		development of enough sense of the material in <i>The 
		<a href="../compsci.htm#Knuth97">Art of Computer Programming</a></i> to be able to read the discussions 
		of algorithms there, even if you never use the particular 
		implementations.</font></dd>
      <dd><font size="-1">
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;<i>A version of this précis is published <a href="http://www.amazon.com/exec/obidos/ASIN/0201066734" target="_top">
		on amazon.com</a>.</i></font></dd>
    </dl>
  

<p align="center"><font size="-1"><b><a href="#v0.2.1">V<span style="font-variant: small-caps">ersion</span>
 0.2.1</a> L<span style="font-variant: small-caps">ast updated</span>
 2002-10-13-12:32 -0700 (pdt)</b></font></p>

<hr>


<blockquote>


<h3 align="left">
        <i><a href="#Summary">Summary</a></i>
        </h3>


</blockquote>


<dl><b><font size="+1">
      <dt><font size="+2">
        1. <a href="#AlgorithmImplementations">Implementations of Algorithms</a>
      </font></dt>
      <dd>1.1&nbsp;<a href="#BinarySearchImplementation">A Binary Search 
		Implementation</a><br>
        1.2 <a href="#BinarySearchAlgorithm"> A Binary Search Algorithm</a><br>
        1.3 <a href="#AlgorithmImplementationDance"> Dancing Between Algorithm 
		and Implementation</a></dd>
      <dt>&nbsp;</dt>
      <dt><font size="+2">2. <a href="#AlgorithmicBaggage"> Algorithmic Baggage</a></font></dt>
      <dd>&nbsp;</dd>
      <dt><font size="+2">3. <a href="#AbstractingAlgorithms"> Abstracting 
		Algorithms</a></font></dt>
      <dd>&nbsp;</dd>
      <dt><font size="+2">4. <a href="#SeparatingAlgorithmImplementationDesign"> 
		Separating Algorithm, Implementation, and Design</a></font></dt>
      
  </dl>


  <blockquote>
    <h3><i><a href="#References">References</a></i></h3>
  </blockquote>
      
</font></b>


<hr>


<h2 align="left">
        <a name="Summary">Summary</a>
        </h2>


<blockquote>
  <p>What is the relationship between algorithms and their implementations that 
	is important to the mastery of computer programming?&nbsp; Is it 
	foundational merely for computer science or does it inform the development 
	of all successful computing practice?&nbsp;&nbsp;Is there a firm distinction or is it 
	conceptual and qualitative?&nbsp;&nbsp;</p>
  <p><a href="#review">Reviewing</a> <a href="#Sedgewick1989"> Sedgewick&#39;s</a> 
	approach leads me to explore the separateness of algorithms more closely.&nbsp; 
	I conclude that writing down an algorithm in any form commits one to a 
	framework, like it or not.&nbsp; Formalism is like that.&nbsp;&nbsp;</p>
  <p>Even so, I maintain, differentiating statements of algorithms from programs 
	is indispensable.&nbsp; Abstracting algorithms encourages students and 
	practitioners to develop their ability to identify, operate with, and 
	interpret levels of abstractions.&nbsp; It is at the heart of computing.</p>
  <p align="right"><i>-- Dennis E. Hamilton<br>
  2001 January 7</i></p>
</blockquote>


<h1 align="left">
        1. <a name="AlgorithmImplementations">Implementations of Algorithms</a>
        </h1>


<blockquote>


<p align="left">Every time we look at the implementation of an algorithm, we see 
more than the algorithm.&nbsp; An implementation always adds more detail than 
what is essential to the algorithm.&nbsp; An implementation is also likely to 
take something away from the algorithm.
        </p>


</blockquote>


<h2 align="left">1.1 <a name="BinarySearchImplementation"> A Binary Search 
Implementation</a>
        </h2>


<blockquote>


<p align="left">There is an useful example on the Miser Project page of&nbsp; <a href="http://miser-theory.info/notations.htm#CodeData">
notations</a>
for code and data: two implementations of the same algorithm are presented.&nbsp; 
One implementation is in Python, the other is in C Language.&nbsp; The 
implementations are clearly different, far more than the superficial similarity 
of language constructs reveals.&nbsp; But the algorithm is the same.&nbsp; It is 
a flavor of Donald E. Knuth&#39;s 
<a href="#ACP6.2.1B"> Algorithm&nbsp;6.2.1B</a>.
        </p>


<p align="left">Here is the more-general implementation, the one in Python:
        </p>


<blockquote>
      <pre><code><font color="#000000"><b>def</b> <a name="BinSearch" href="http://miser-theory.info/BinSearch.py">BinSearch</a>(<i>List</i>, <i>item</i>):
    &quot;return the index of <i>item</i> in the already-sorted <i>List</i>&quot;
    &quot;return -1 when <i>item</i> is not in <i>List</i>&quot;
    &quot;based on Donald E. Knuth&#39;s Algorithm <a href="#ACP6.2.1B">6.2.1B</a>&quot;
    &quot;  cleaned up to work with 0-origin lists, tuples, and indexes&quot;
    L = 0                    # Current left-most position
    R = len(<i>List</i>)            # Current right boundary
    <b>while</b> L &lt; R:
        j = (L + R) / 2      # A place to try in the 
        <b>if</b> <i>List</i>[j] == <i>item</i>:  #   candidate interval
            <b>return</b> j
        <b>if</b> <i>List</i>[j] &lt; <i>item</i>:   # When no match yet, close off
            L = j + 1        #   the area where <i>item</i> can&#39;t be
        <b>else</b>:                #   and continue in the interval
            R = j            #   that remains
    <b>return</b> -1                # Return impossible index if no match</font></code></pre>

</blockquote>


<p align="left">&nbsp;This version is similar to a statement of the essential 
algorithm, yet it does not provide a precise statement of the algorithm.&nbsp; 
Far from it.&nbsp;&nbsp;
        </p>


<p align="left">Notice that there are a number of assumptions lurking behind 
this implementation:
        </p>


<ul>
  <li>
    <p align="left">We assume that <code>len(<i>List</i>)</code> is always 
	representable as an exact integer value and there is no risk of <i><code>
	List</code></i>
    having more elements than the largest representable integer.&nbsp; It is 
	further assumed that (<code>len(<i>List</i>)-1)+len(<i>List</i>)</code> (the 
	worst-case value of <code>L+R</code>) is also computed precisely.</li>
  <li>
    <p align="left">The Python version operates properly with any <i><code>item</code></i>
    and <code><i>List</i></code>-item data type such that the values are 
	comparable and are simply ordered by operator &lt;.</li>
  <li>
    <p align="left"><code>BinSearch</code> employs an impossible index (for 
	Python lists) of <code>-1</code> to report unsuccessful completion of the 
	search.&nbsp; The implementation assures that this value cannot arise as a 
	successful result.</li>
  <li>
    <p align="left">The program variables <code>L</code>, <code>R</code>, and <code>
	j</code>
    are private to the implementation and the only operations with them are 
	those that are shown.&nbsp;&nbsp;</li>
  <li>
    <p align="left">The parameters <i><code>List</code></i> and <i><code>item</code></i>
    are assumed to be stable and non-volatile, with no alteration occurring to 
	them while <code>BinSearch</code> is being carried out.</li>
  <li>
    <p align="left">The operations are clearly stated, but the identification of 
	the particular algorithm and preservation of essential conditions is by 
	appeal to a separate publication [<a href="#ACP6.2.1B">ACP 6.2.1B</a>]</li>
</ul>


</blockquote>


<h2 align="left">1.2 <a name="BinarySearchAlgorithm"> A Binary Search Algorithm</a>
        </h2>


<blockquote>
  <p align="left">To see the difference between the statement of an algorithm 
	for binary search and the <code><b>BinSearch</b></code> implementation, we 
	will use the style of algorithm presentation introduced by Donald Knuth[<a href="#Knuth1997">Knuth1997</a>: 
	1.1]:
        </p>


  <blockquote>


  <p align="left"><b>Algorithm Bin</b> (<i>Binary search</i>).&nbsp; Given a 
	list of items <i>K</i><sub>0</sub>, <i>K</i><sub>1</sub>, ..., <i>K</i><sub>N-1</sub><sub><br>
  </sub>in non-decreasing order <i>K</i><sub>0</sub>  <u> &lt;</u> <i>K</i><sub>1</sub> 
  <u> &lt;</u> ··· <u>
  &lt;</u> <i>K</i><sub>N-1</sub>,&nbsp;<br>
 	this algorithm finds a position, if any, having a given item, <i>K</i>.
        </p>



<dl>
      <dt><b>Bin1.</b> [Initialize.]</dt>
      <dd>Set <i>L</i> to 0; set <i>R</i> to <i>N</i>,<i> </i>the number of 
		items.<br>
        (If there are no items, <i>N</i> is 0.) 
      </dd>
      <dt>&nbsp;</dt>
      <dt><b>Bin2.</b>  [Out of Luck?]</dt>
      <dd>Let <i>Rem</i> = <i>R</i> - <i>L</i>, the number of eligible items 
		remaining.<br>
        If <i>Rem</i> = 0, terminate the search as unsuccessful.<br>
        (Each time we return to Bin2, <i>Rem</i> is smaller and we must 
		eventually find a matching item or terminate with all possibilities 
		eliminated.&nbsp; See Bin4 and Bin5 to confirm that.)</dd>
      <dt>&nbsp;</dt>
      <dt><b>Bin3</b>. [Take a Look.]</dt>
      <dd>(<i>L</i> &lt; <i>R</i> and if <i>K</i> is among the eligible items then <i> 
		K</i><sub><i>L</i></sub> <u>&lt;</u>  <i> K</i> <u>&lt;</u>  <i> K</i><sub><i>R</i>-1</sub>.)<br>
        Set <i>j</i> to floor((<i>L</i>+<i>R</i>)/2).</dd>
      <dd>(<i>j</i> is always an index within one place of the middle of the 
		interval <i>L</i> 
        through <i>R</i>-1.&nbsp; <i>L</i> <u>&lt;</u> <i>j</i> <u>&lt;</u> <i>R</i>-1 
		always.)<br>
        If <i>K</i><sub><i>j</i></sub> &lt; <i>K</i>, go to Bin4.&nbsp; If <i>K</i>
        &lt; <i>K<sub>j</sub></i>, go to Bin5.<br>
        Otherwise, the search is successful and <i>K</i><i><sub>j</sub></i> is a 
		matching item.</dd>
      <dt>&nbsp;</dt>
      <dt><b>Bin4.</b> [Look Higher Next.]</dt>
      <dd>(If <i>K</i> is among the eligible items, then <i>K</i><sub><i>j</i>+1</sub>
        <u>&lt;</u> <i>K</i> <u>&lt;</u> <i>K</i><sub><i>R</i>-1</sub>.)</dd>
      <dd>Set <i>L</i> to <i>j</i>+1.&nbsp; Go to Bin2.<br>
        (0 <u>&lt;</u> <i>R</i> - <i>L</i> &lt; <i>Rem</i>.&nbsp; We have eliminated 
		at least half of the current items as ineligible.)</dd>
      <dt>&nbsp;</dt>
      <dt><b>Bin5.</b> [Look Lower Next.]</dt>
      <dd>(If <i>K</i> is among the eligible items, then <i>K<sub>L</sub></i> <u>
		&lt;</u>
        <i>K</i> <u>&lt;</u> <i>K</i><sub><i>j</i>-1</sub>.)<br>
        Set <i>R</i> to <i>j</i>.&nbsp; Go to Bin2.<br>
        (0 <u>&lt;</u> <i>R</i> - <i>L</i> &lt; <i>Rem</i>.&nbsp; We have eliminated 
		at least half of the current items as ineligible.)</dd>
  
</dl>
  </blockquote>
  <p>The statement of the algorithm relies on a supposedly pre-existing 
	framework.&nbsp; We will discuss that more in section 2.&nbsp; For now, it 
	is valuable to notice that there is an implicit framework and perhaps ponder 
	(1) how much of it we take for granted in reading the algorithm and (2) how 
	much the author of this description takes for granted about what needs to be 
	said and what it takes to understand it.</p>
  <p>This statement of the algorithm is contrived so that someone skilled in the 
	analysis of algorithms can independently confirm some important 
	characteristics:</p>
  <ul>
    <li>The preconditions in which the algorithm is assured to operate are 
	clearly established.</li>
    <li>We rely on&nbsp; mathematical objects, not computational ones, so there 
	is a generality beyond the incomplete data representations that arise in 
	typical implementations.</li>
    <li>All operations are definite and presumed to be carried out in finite 
	time and space.&nbsp; This includes use of floor(<i>x</i>) for the largest 
	integer not greater than <i>x</i>.&nbsp;&nbsp;</li>
    <li>At the same time, we are not so definite as to fix the operations in a 
	rigid way.&nbsp; It is presumed that there is or can be made to be such a 
	fixation when the algorithm is embodied in an implementation.</li>
    <li>No indefinite operations (e.g., reference to <i>K<sub>N</sub></i> or <i>
	K</i><sub>-1</sub>) are ever attempted.</li>
    <li>The algorithm must terminate.</li>
    <li>If the input conditions are satisfied, the algorithm accurately 
	determines an index for a <i>K</i>-matching item if and only if there is 
	one.&nbsp; The algorithm will terminate unsuccessfully if and only if there 
	is no <i>K</i>-matching item.</li>
    <li>One can analyze the performance of the algorithm in terms of the number 
	of times step Bin3 is ever performed.</li>
    <li>There is a way of speaking of algorithms as if they exist, yet the 
	statements of them are not the algorithms (not unlike the concern we began 
	with, involving recognition of algorithms embodied in implementations).</li>
  </ul>
  <p>Also, notice that the annotations made as parenthetical comments are not 
	strictly part of the statement of the algorithm.&nbsp; The annotations 
	provide assertions about the algorithm that are important in comprehending 
	the achievement of its function and of its efficacy.&nbsp; The annotations 
	also support confirmation that the recipe given is indeed that of an 
	algorithm for the identified function.</p>
  <p style="border-style: double"><i>We are looking here at a few ideas that 
	might be worth developing separately:&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp; 1. That the statement of an algorithm has a certain 
	looseness to it that is important.&nbsp; Yet it is easy to reach agreement 
	and demonstration that there is an interpretation of the statement in an 
	implementation that preserves the essentials of the algorithm.<br>
  &nbsp;&nbsp;&nbsp;&nbsp; 2. That implementations can be viewed as 
	interpretations of (formal or informal) algorithms<br>
  &nbsp;&nbsp;&nbsp;&nbsp; 3. That the annotations are <b>indispensible</b> to 
	the statement of the algorithm and it being seen as satisfying the 
	requirements for for accomplishment of the stated purpose with an 
	algorithmic solution.</i></p>
  <p style="border-style: double"><i>It will probably be valuable to identify 
	what the technical conditions on algorithms are and how they are satisfied 
	with this particular example.&nbsp; I will do that in Miser Note n010207: <a href="https://miser-theory.info/notes/2001/02/n010207.htm">
	What&#39;s an Algorithm</a>?<br>
  </i>&nbsp;&nbsp;&nbsp;&nbsp; <i>At some point, we want to nail down this way 
	of speaking about the statement of an algorithm, versus the algorithm, 
	versus an implementation of the algorithm in a computer program.&nbsp; We 
	want to establish that, whatever the difficulties that even the statement of 
	an algorithm introduces on &quot;grokking&quot; the algorithm, it is valuable to take 
	that route. (2001-02-20)</i></p>
</blockquote>


  <h2>1.3 <a name="AlgorithmImplementationDance"> Dancing Between Algorithm and 
	Implementation</a></h2>
<blockquote>
  <p align="left">When I am working with statements of algorithms and 
	implementations, I toggle back and forth between them.&nbsp; Experiences in 
	developing the implementation suggest refinements -- usually simplifications 
	-- to the algorithm and its statement that are then reflected by economies 
	in the implementation.&nbsp; The process can continue until I am satisfied 
	with the result.&nbsp;&nbsp;<p align="left">When I developed <code><a href="#BinSearch">
	BinSearch</a></code>, I started by consulting Knuth&#39;s statement of <a href="#ACP6.2.1B">
	Algorithm 6.2.1B</a>.&nbsp; I immediately introduced transformations that 
	allowed my preferred style to be expressed in <code><a href="#BinSearch">
	BinSearch</a></code>,.&nbsp; I satisfied myself that none of the 
	transformations sacrificed anything that is essential to preserving the 
	algorithm, its correctness, or its performance.&nbsp;&nbsp;<p align="left">I did all 
	of this informally, the objective at the time being providing an useful 
	worked example of notational conventions and their application, not 
	demonstrating algorithmic analysis.<p align="left">In questioning whether 
	programs teach algorithms, I took a fresh look.&nbsp; Although I again 
	consulted Algorithm 6.2.1B, this time I created Algorithm Bin by 
	re-abstraction from BinSearch.&nbsp; I Also restated it in a way where I 
	could demonstrate that I had captured everything that there is in Algorithm 
	6.2.1B, and more.<p align="left" style="border-style: double"><i>Discuss how 
	the statement of Algorithm Bin has a pleasant separation of concerns.&nbsp; 
	It is abstracted completely away from any application.&nbsp; Contrast this 
	with Knuth&#39;s statement, and also with Sedgewick&#39;s.&nbsp; This is an useful 
	illustration in the abstraction of design from algorithm and of algorithm 
	from implementation.&nbsp; (Both Knuth and Sedgewick cast the algorithm in 
	the context of a wider purpose.&nbsp; We can reflect that in the discussion 
	of design vs. algorithm.)&nbsp; 2001-02-20.</i><p align="left" style="border-style: double"><i><br>
  &nbsp;&nbsp;&nbsp;&nbsp; Talk about why I don&#39;t go the final step and use </i><code><b>
	while</b> (L != R):</code><i>, leaving the safety cord attached even when it 
	is demonstrably unnecessary.<br>
  &nbsp;&nbsp;&nbsp;&nbsp; In creating Algorithm Bin as a re-abstraction of </i><b><code>
	BinSearch</code></b><i>, it is not like I walked up with a blank mind and 
	then figured out an abstraction that gave me an algorithm I could use.&nbsp; 
	I was certainly aware of the function of </i><b><code>BinSearch</code></b><i> 
	and what it was intended to accomplish by me, its author.</i><p align="left" style="border-style: double"><i>
	We can consider decorating code with information about the algorithm.&nbsp; 
	This might be a form of tangling that has the algorithm carried with the 
	code so that someone can inspect it as a whole.&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp; The value of that is that the code is tied to the 
	algorithmic statement that it provides a valid interpretation of.&nbsp; It 
	puts rigor around what the intended function is, and the only knowledge of 
	the implementation that it is safe for an user of the implementation to make 
	(assuming that one might want to substitute a different implementation that 
	preserves the agreed interface and the algorithm).<br>
  &nbsp;&nbsp;&nbsp;&nbsp; If I were to do that, I would want a very clear 
	notation for distinguishing discussion about the implementation from the 
	annotations that tie the implementation to the algorithm.&nbsp; This might 
	make for some wordy code.&nbsp; It would certainly have a valuable 
	self-contained property to it.&nbsp; It is apparently not what most 
	programmers want to look at.<br>
  &nbsp;&nbsp;&nbsp;&nbsp; I would also want a way of tying implementation 
	conditions and restraints, so that the mapping of the algorithm is very 
	clear, and the restraints of the implementation are also separately very 
	clear.&nbsp; I am thinking of constraints like Bin&#39;s L+R being a defined 
	quantity in the operational system of the implementation.<br>
  &nbsp;&nbsp;&nbsp;&nbsp; If I attempt this, it will be by coming up with a new 
	version of </i><code><b>BinSearch</b></code> <i>here.</i>
</blockquote>
    <h1 align="left">2. <a name="AlgorithmicBaggage"> Algorithmic Baggage</a></h1>
<blockquote>
  <p align="left" style="border-style: double"><i>Point out that we pretty much 
	always say more than is essential.&nbsp; And it is still important to have a 
	form of expression that has it be understood that the algorithm is 
	definitely and always more abstract than the implementation.<br>
  &nbsp;&nbsp;&nbsp;&nbsp; Every expression of an algorithm has baggage.&nbsp; 
	This includes assumptions about the existence of orderings, the assumption 
	of 0-origin indexing, the use of natural numbers for indexes, and the 
	stability of the objects involved.&nbsp; That the algorithm is effectively 
	carried out atomically, while itself being composed of definite steps, is a 
	key assumption in almost all expression of algorithms.&nbsp; This is part of 
	the framework.<br>
  &nbsp;&nbsp;&nbsp;&nbsp; Then there is the simple use of ordinary language 
	along with borrowing of mathematical objects and notations, all more 
	framework for expressing algorithms.&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp; The value of using ordinary language and distinct 
	notations from that for program code must not be underestimated.&nbsp; It 
	gives us a way of distinguishing the two, and of being able to establish 
	what is essential and what is incidental (but perhaps inescapable baggage) 
	of the given implementation.&nbsp; We can also begin to separate the baggage 
	of the algorithmic framework and the baggage of the implementation system.<br>
  &nbsp;&nbsp;&nbsp;&nbsp; It is important that we appreciate the value of 
	having more than one perspective on this.&nbsp; It gives us a place to 
	separate problem from solution, and be clear which is a statement of what.&nbsp; 
	the algorithm-implementation separation contributes to the separation of the 
	abstraction from the statements of it.&nbsp;&nbsp;</i>
</blockquote>
    <h1 align="left">3. <a name="AbstractingAlgorithms"> Abstracting Algorithms</a></h1>


<blockquote>


<p align="left" style="border-style: double"><i>Consider that the level of 
abstraction for statements of algorithms might need to be improved.&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp; One way is to notice that the objects appealed to in 
the statement of the algorithm might be at the wrong level.&nbsp; A large part 
of the baggage in our example is related to the level at which we deal with 
ordered lists via indexes.&nbsp; There might be a way to change the level such 
that we address lists in other terms that are somehow liberated from the baggage 
about indexes and their origins.&nbsp; It might be a quite different algorithm, 
assuming quite different basic operations, and we won&#39;t go there.<br>
&nbsp;&nbsp;&nbsp;&nbsp; Another approach is to make reliance on abstract 
elements explicit rather than tacit.&nbsp; What we might get to is a form of 
expression of algorithms that can be taken as concrete, given a representation 
of the abstract elements.&nbsp;&nbsp;</i>
        </p>


<p align="left" style="border-style: double"><i>
&nbsp;&nbsp;&nbsp;&nbsp; We are always going to have algorithmic baggage.&nbsp; 
Can we arrange baggage in such a way that the baggage is understandable and the 
abstracted algorithm is pretty clear?&nbsp; We take a look at a toy case using 
an abstract structure for the bit.<br>
&nbsp;&nbsp;&nbsp;&nbsp; This might be better described as <b>manifesting 
abstractions</b>.&nbsp; That is, we want to make the subject-matter of the 
algorithm, the structures that are understood, explicitly abstracted so that we 
can see what the dependencies are.&nbsp; To do this, we still need a framework, 
but one that makes explicit that which was originally tacit.&nbsp; (2001-02-20, 
2001-02-23)</i>
        </p>


<p align="left" style="border-style: double"><i>I don&#39;t know that I want to go 
far down this road here.&nbsp; What I might want to say is more about how 
algorithms are not what we write down.&nbsp; When we make a statement of an 
algorithm, we provide an expression in which is to be seen a method.&nbsp; What 
we are up to here is finding a couple of viewpoints that allow the abstraction, 
the algorithm, to be discerned.&nbsp; The idea of manifesting abstractions is an 
useful one, but the illustration of bits and such creates a long diversion.&nbsp; 
What I am going to do is posit the value of manifesting abstractions, include a 
diagram, and leave it like that.&nbsp; I argue that it is particularly useful to 
have the statement of an algorithm and also an implementation.&nbsp; The 
difference between stating an algorithm and being one is also important and 
perhaps most to the point here. (2001-02-23)</i>
        </p>


</blockquote>


    <h1 align="left">4. <a name="SeparatingAlgorithmImplementationDesign"> 
	Separating Algorithm, Implementation, and Design</a></h1>


<blockquote>


<p align="left" style="border-style: double"><i>We then look at what may well be 
the likely case in a practical situation.<br>
&nbsp;&nbsp;&nbsp;&nbsp; 1. We confess that we came in with a point of view 
about conceptual abstractions, and make the best of it.<br>
&nbsp;&nbsp;&nbsp;&nbsp; 2. We look at the motivation for doing this, and why we 
don&#39;t want to collapse algorithms and implementations together.&nbsp; Part of it 
has to do with coming to grips with what is essential.&nbsp; We have a practical 
example of what is available when we bother to do that.&nbsp; (I have another 
example in the Dr. Dobb&#39;s paper on integer powers.)<br>
&nbsp;&nbsp;&nbsp;&nbsp; 3. There is also an example in why we often do applied 
mathematics the way we do, whether balancing a checkbook or building a table or 
playing pool or pitching at baseball, when we bother to look at these activities 
that way.</i>
        </p>


<p align="left" style="border-style: double"><i>There is an example of design 
versus algorithm in what we want to represent versus how we are representing it 
(algorithmically).&nbsp; Also, the combination of algorithms that go into the 
design of something can have algorithms at a quite different level of 
abstraction than that of the design.</i>
        </p>


<p align="left" style="border-style: double"><i>We should also differentiate a 
requirement from a design.&nbsp; That is, something that provides a purposive 
setting that any design must fit within as its context.&nbsp; The design is a 
bridge between the requirements and the computational methods that will satisfy 
the requirements.&nbsp; The design tends to allocate functions, and these 
functions will be mechanized using methods and algorithms.&nbsp; There are 
different abstractions at these different levels.&nbsp; And they are related but 
not in a strict way.&nbsp; The design establishes what is essential about those 
relationships.&nbsp; (2001-02-23)</i>
        </p>


</blockquote>


<h2 align="left"><i><a name="References">References</a></i>
        </h2>


<blockquote>


<dl>
 
    <dt><a name="ACP6.2.1B">[ACP 6.2.1B]</a></dt>
    <dd>Knuth, Donald E.&nbsp; Binary Search.&nbsp; Algorithm 6.2.1B on p. 410 
	of <i><a href="../compsci.htm#Knuth1998b">The Art of Computer Programming</a></i><a href="../compsci.htm#Knuth1998b">,
      <i>v.3: Sorting and Searching</i></a>.&nbsp; ed.2.&nbsp; Addison-Wesley 
	Longman (Reading, MA: 1998).&nbsp; ISBN 0-201-89685-0.&nbsp;&nbsp; <font size="-1"><b>&nbsp;&nbsp;&nbsp;&nbsp; <code><br>
      </code>&nbsp;&nbsp;&nbsp;&nbsp; <code><a href="#BinSearch">BinSearch</a></code></b>
      is derived from the form given by Knuth in <i>Scientific American</i> <b>
	236</b>, 4 (April 1977), as reprinted on pp.66-67 of <i>
	<a href="../compsci.htm#Knuth1996">Selected Papers on Computer Science</a>,</i> 
	CSLI (Palo Alto: 1996),&nbsp; ISBN 1-881526-91-7 pbk.<br>
      &nbsp;&nbsp;&nbsp;&nbsp; This <b><a href="#BinSearch"><code>BinSearch</code></a></b>
      is adjusted to avoid wondering what <code><b><i>m</i>/2</b></code> might 
	be for integer <b><code><i>m</i>&lt;0</code></b>, while preserving a clean 
	terminating condition and loop invariant.&nbsp; It is required that <b><code>
	(2*<i>i</i>+1)/2</code></b>
      be <i><code><b>i</b></code></i>
      for non-negative <b><i><code>i</code></i></b>.</font></dd>
 
    <dt>&nbsp;</dt>
      <dt><a name="Knuth1997" href="../compsci.htm#Knuth1997">[Knuth1997]</a></dt>
      <dd>Knuth, Donald E.&nbsp; <i><a href="../compsci.htm#Knuth1997">The Art 
		of Computer Programming, vol.1: Fundamental Algorithms</a></i>. ed.3.&nbsp; 
		Addison Wesley Longman (Reading, MA: 1997).&nbsp; ISBN 0-201-89683-4.</dd>
 
    <dt>&nbsp;</dt>
      <dt>[<a name="Polya1957" href="../math.htm#Pólya1957">Pólya57</a>]</dt>
      <dd>Pólya, George.&nbsp; <i>How to Solve It</i>.&nbsp; ed.2.&nbsp; 
		Princeton University Press (Princeton, NJ: 1945, 1957).&nbsp; ISBN 
		0-691-08097-6.</dd>
      <dt>&nbsp;</dt>
 
    <dt><a name="Sedgewick1989" href="../compsci.htm#Sedgewick1989">
	[Sedgewick1989]</a></dt>
    <dd>Sedgewick, Robert.&nbsp; <i>Algorithms</i>.&nbsp; Second edition.&nbsp; 
	Addison-Wesley (Reading, MA: 1983, 1988).&nbsp; 1989 reprint with authors 
	corrections.&nbsp; ISBN 0-201-06673-4.</dd>
 
</dl>


<font face="Arial, Microsoft Sans Serif, Helvetica, Geneva, Swiss, Sans Serif">

<hr color="#990033">

</font>


</blockquote>


<h3 align="left"><i><a name="History">History</a></i></h3>

<blockquote>
  <dl><font size="-1">
      <dt><b><a name="v0.3.0">0.3.0</a> 2023-10-01 Repurposed to 
		orcmid.github.io/bib</b></dt>
	<dt><b><a name="v0.2.1">0.2.1</a> 2002-10-13 Last Updated on the Miser Site</b></dt>
	<dt><b><a name="0.20">0.20</a> 2001-02-23 Separate extended material</b>
        (orcmid)</dt>
      <dd>A <a href="r010101a.htm">long-winded version</a> of this note is 
		frozen and separated.&nbsp; This draft is now available for pruning down 
		to the essential ideas, with references to articles having extended 
		development under the 
		<a target="_top" href="https://orcmid.github.io/miser">Miser Project</a>.&nbsp;</dd>
      <dt><b><a name="0.10">0.10</a>  2001-02-23 Prepare for division into 
		separate articles</b> (orcmid).</dt>
      <dd>This note becomes the common basis for several articles that address 
		the underlying themes more carefully.</dd>
      <dt><b><a name="0.00">0.00</a> 2001-01-04</b> <b>Initiate &quot;<a href="R010101.htm">Do 
		Programs Teach Algorithms?</a>&quot;</b> (orcmid)</dt>
      <dd>On re-examinination of&nbsp; Sedgwick&#39;s <i><a href="#Sedgewick1989">
		Algorithms</a></i>, I noticed that there seems to be a <a href="#review">
		collapse</a> of algorithms with their implementations, and that 
		algorithms are not directly addressed.&nbsp; This reminded me of earlier 
		work, &quot;Programs Are Rarely Algorithms&quot; that I&#39;d discussed with Bill 
		Anderson in the 80&#39;s.&nbsp; It seemed important to speak up about it 
		here, especially in light of my inquiry into &quot;concrete abstractions&quot; 
		(now termed manifest abstractions).</dd>
  </font></dl>
</blockquote>

<p align="right">&nbsp;</p>

<table border="0" cellspacing="3" width="100%">
  <tr>
    <td width="10%">
	<a href="index.htm">
	<img border="0" src="../../images/hardhat-thumb.gif" width="80" height="60" alt="Construction Structure (Hard Hat Area)"></a></td>
    <td width="67%" valign="middle" align="center">
      <!--webbot bot="Include" U-Include="../../construction/templates/00/c000005d.htm" TAG="BODY" startspan -->
<font face="Arial, Microsoft Sans Serif, Helvetica, Geneva, Swiss, Sans Serif">
<small><!-- Included from orcmid.github.io/construction/templates/00/c000005c.htm
                of 2023-09-02T00:20Z -->
<small>You are navigating <a rel="nofollow" href="../../" target="_top">Orcmid on GitHub</a></small></small></font>
<!--webbot bot="Include" i-checksum="4086" endspan -->
    </td>
    <td width="21%">
      <p align="right"><font size="-2">created 2001-01-04-12:40 -0800&nbsp; 
		(pst) by 
		<a href="../../orcmid" target="_top">orcmid </a></font></p>
    </td>
  </tr>
</table>

</body>
</html>
