<html>

<head>
<title>R010101a: Abstracting Algorithms from Programs</title>
<!--$$Header: /nfoCentrale Compagno Web/orcmid/readings/R010101a.htm 15    02-10-13 12:49 Orcmid $-->
</head>

<body bgcolor="#FFFFFF" link="#0000FF" vlink="#800080" alink="#FF0000" text="#000080">

<h1 align="center"><a href="../../readings/">Reading</a>
Notes</h1>

<h1 align="center"><a href="r010101.htm">R010101</a>a:
Abstracting Algorithms from Programs</h1>


    <dl>
      <dd><b><a name="review">Sedgewick, Robert</a>.&nbsp; <i><a href="../compsci.htm#[Sedgewick89]">Algorithms</a></i>.&nbsp; Second
        edition.&nbsp; Addison-Wesley (Reading, MA: 1983, 1988).&nbsp; 1989
        reprint with authors corrections.&nbsp; ISBN 0-201-06673-4.</b></dd>
      <dd><font size="-1">
        &nbsp;&nbsp;&nbsp;&nbsp; This book presents an interesting
  challenge.&nbsp; It talks about algorithms but it does not show any
  algorithms, nor does it define algorithm as anything more than a
  &quot;problem-solving method suitable for implementation as computer programs.
  [p.4]&quot;&nbsp; Instead, it exhibits programs which are the implementations
  of algorithms and discusses them as if the algorithm is apparent.&nbsp; The
  reader is left with the challenge of learning to discriminate between what is
  essential about an algorithm, and how to preserve that in an implementation,
  versus what is inessential to the algorithm and introduced on account of the
  implementation and the use of particular programming tools.&nbsp; I am
  concerned that this approach, while well-motivated, is not successful.&nbsp; My evidence is in the criticisms of this and later editions
        that dwell on the
  choice of programming language and on stylistic matters in the use of the chosen
        language.&nbsp; This places too much emphasis on code. &nbsp; Although code rules these days,
        I remain unconvinced that this simplification is a good thing.&nbsp; For
        me, one of the great insights in development of software is
        identification of layers of abstraction for conquering the organization
        of complex application programs.&nbsp; Separating design, algorithm and
        implementation is a critical first step toward that mastery.&nbsp;<br>
        &nbsp;&nbsp;&nbsp;&nbsp; Meanwhile, <i>Algorithms</i> serves up a handy
        set of recipes for a variety of basic computing situations.&nbsp; The 45
        sections cover fundamental methods of widespread application in
        computing and software development. The presentations are
        straightforward and illuminating.&nbsp; The compilation bears
        re-examination every time one sits down to identify key methods for a
        new application.&nbsp; I recommend supplementing this material with the
        practical methods of <i>Software Tools</i> and the introspective
        explorations of <i>Programming Pearls</i>.&nbsp; Most of all I encourage
        development of enough sense of the material in <i>The <a href="../compsci.htm#[Knuth97]"> Art of Computer
        Programming</a></i> to be able to read the discussions of algorithms there,
        even if you never use the particular implementations.</font></dd>
      <dd><font size="-1">
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;<i>A version of this précis is
        published <a href="http://www.amazon.com/exec/obidos/ASIN/0201066734" target="_top">on
        amazon.com</a>.</i></font></dd>
    </dl>
  

<p align="center"><font size="-1"><b><a href="#0.15">V<span style="font-variant: small-caps">ersion</span>
 0.15</a> L<span style="font-variant: small-caps">ast updated</span>
 2001-02-23-09:53 -0800 (pst)</b></font></p>

<blockquote>
  <p align="left"><font size="-1"><b>This is a snapshot of in-progress
  work.&nbsp; There is no further development on this note.&nbsp; Continuation
  of this inquiry is in the following and related materials:</b></font></p>

  <ul>
    <li>
      <p align="left"><font size="-1"><b>R010101: <a href="r010101.htm">Do
      Programs Teach Algorithms?</a></b></font></li>
    <li>
      <p align="left"><font size="-1"><b>Miser Note N010201: <a href="http://miser-theory.info/notes/n00-log.htm#N010201">Manifest
      Abstractions</a></b></font></li>
    <li>
      <p align="left"><font size="-1"><b>Miser Note N010202: <a href="http://miser-theory.info/notes/n00-log.htm#N010202">Homage
      to the Bit</a></b></font></li>
    <li>
      <p align="left"><font size="-1"><b>Miser Note N010204: <a href="http://miser-theory.info/notes/n00-log.htm#N010204">Framework
      Versus Structure</a></b></font></li>
    <li>
      <p align="left"><font size="-1"><b>Miser Note N010205: <a href="http://miser-theory.info/notes/n00-log.htm#N010205">Programs
      Are Rarely Algorithms</a></b></font></li>
  </ul>
</blockquote>

<hr>


<blockquote>


<p align="left" style="border-style: double"><i>This is becoming too long and wandering quite a ways beyond the
original inspiration in <a href="#[Sedgewick89]">Algorithms</a>.&nbsp;
The article will be separated as an independent work and this commentary will
simply link to it.&nbsp; The article will still be on Do Programs Teach
Algorithms, but the longer, detailed excursions will be pulled into articles of
their own (such as Homage to the Bit and others being worked up as part of the
Miser Project.)</i>
        </p>


<h3 align="left">
        <i><a href="#Summary">Summary</a></i>
        </h3>


</blockquote>


<dl><b><font size="+1">
      <dt><font size="+2">
        1. <a href="#AlgorithmImplementations">Implementations of Algorithms</a>
      </font></dt>
      <dd>1.1&nbsp;<a href="#BinarySearchImplementation">A Binary Search Implementation</a><br>
        1.2 <a href="#BinarySearchAlgorithm"> A Binary Search Algorithm</a><br>
        1.3 <a href="#AlgorithmImplementationDance"> Dancing Between Algorithm and Implementation</a></dd>
      <dt>&nbsp;</dt>
      <dt><font size="+2">2. <a href="#AlgorithmicBaggage"> Algorithmic Baggage</a></font></dt>
      <dd>&nbsp;</dd>
      <dt><font size="+2">3. <a href="#AbstractingAlgorithms"> Abstracting Algorithms</a></font></dt>
      <dd>&nbsp;</dd>
      <dt><font size="+2">4. <a href="#SeparatingAlgorithmImplementationDesign"> Separating Algorithm, Implementation, and Design</a></font></dt>
      
  </dl>


  <blockquote>
    <h3><i><a href="#Summary">References</a></i></h3>
  </blockquote>
      
</font></b>


<hr>


<h2 align="left">
        <a name="Summary">Summary</a>
        </h2>


<blockquote>
  <p>What is the relationship between algorithms and their implementations that
  is important to the mastery of computer programming?&nbsp; Is it foundational
  merely for computer science or does it inform the development of all
  successful computing practice?&nbsp;&nbsp;Is there a firm distinction or is it
  conceptual and qualitative?&nbsp;&nbsp;</p>
  <p><a href="#review">Reviewing</a> <a href="#[Sedgewick89]"> Sedgewick's</a> approach leads me to explore the separateness of
  algorithms more closely.&nbsp; I conclude that writing down an algorithm in
  any form commits one to a framework, like it or not.&nbsp; Formalism is like
  that.&nbsp;&nbsp;</p>
  <p>Even so, I maintain, differentiating statements of algorithms from programs is
  indispensable.&nbsp; Abstracting algorithms encourages students and
  practitioners to develop their ability to identify, operate with, and
  interpret levels of abstractions.&nbsp; It is at the heart of computing.</p>
</blockquote>


<h1 align="left">
        1. <a name="AlgorithmImplementations">Implementations of Algorithms</a>
        </h1>


<blockquote>


<p align="left">Every time we look at the implementation of an algorithm, we see
more than the algorithm.&nbsp; An implementation always adds more detail than
what is essential to the algorithm.&nbsp; An implementation is also likely to
take something away from the algorithm.
        </p>


</blockquote>


<h2 align="left">1.1 <a name="BinarySearchImplementation"> A Binary Search Implementation</a>
        </h2>


<blockquote>


<p align="left">There is an useful example on the Miser Project page of&nbsp; <a href="http://miser-theory.info/notations.htm#CodeData">notations</a>
for code and data: two implementations of the same
algorithm are presented.&nbsp; One implementation is in Python, the other is
in C Language.&nbsp; The implementations are clearly different, far more than the superficial similarity of language constructs reveals.&nbsp;
But the algorithm is the same.&nbsp; It is a flavor of Donald E. Knuth's <a href="#[ACP6.2.1B]"> Algorithm&nbsp;6.2.1B</a>.
        </p>


<p align="left">Here is the more-general implementation, the one in Python:
        </p>


<blockquote>
      <pre><code><font color="#000000"><b>def</b> <a name="BinSearch" href="http://miser-theory.info/BinSearch.py">BinSearch</a>(<i>List</i>, <i>item</i>):
&nbsp;&nbsp;&nbsp; &quot;return the index of <i>item</i> in the already-sorted <i>List</i>&quot;
    &quot;return -1 when <i>item</i> is not in <i>List</i>&quot;
&nbsp;&nbsp;&nbsp; &quot;based on Donald E. Knuth's Algorithm <a href="#[ACP6.2.1B]">6.2.1B</a>&quot;
    &quot;  cleaned up to work with 0-origin lists, tuples, and indexes&quot;
&nbsp;&nbsp;&nbsp; L = 0                    # Current left-most position
&nbsp;&nbsp;&nbsp; R = len(<i>List</i>)            # Current right boundary
&nbsp;&nbsp;&nbsp; <b>while</b> L &lt; R:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j = (L + R) / 2      # A place to try in the 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>if</b> <i>List</i>[j] == <i>item</i>:  #   candidate interval
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>return</b> j
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>if</b> <i>List</i>[j] &lt; <i>item</i>:   # When no match yet, close off
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L = j + 1        #   the area where <i>item</i> can't be
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>else</b>:                #   and continue in the interval
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; R = j            #   that remains
    <b>return</b> -1                # Return impossible index if no match</font></code></pre>

</blockquote>


<p align="left">&nbsp;This version is similar to a statement of the essential
algorithm, yet it does not provide a precise statement of the algorithm.&nbsp; Far from
it.&nbsp;&nbsp;
        </p>


<p align="left">Things to notice:
        </p>


<ul>
  <li>
    <p align="left">We assume that <code>len(<i>List</i>)</code> is always representable as
    an exact integer value and there is no risk of <i><code>List</code></i>
    having more elements than the largest representable integer.&nbsp; It is
    further assumed that (<code>len(<i>List</i>)-1)+len(<i>List</i>)</code> (the worst-case value of <code>L+R</code>)
    is also computed precisely.</li>
  <li>
    <p align="left">The Python version operates properly with any <i><code>item</code></i>
    and <code><i>List</i></code>-item data type such that the values are comparable and
    are simply ordered by operator &lt;.</li>
  <li>
    <p align="left"><code>BinSearch</code> employs an impossible index (for
    Python lists) of <code>-1</code> to report unsuccessful completion of the
    search.&nbsp; The implementation assures that this value cannot arise as a
    successful result.</li>
  <li>
    <p align="left">The program variables <code>L</code>, <code>R</code>, and <code>j</code>
    are private to the implementation and the only operations with them are
    those that are shown.&nbsp;&nbsp;</li>
  <li>
    <p align="left">The parameters <i><code>List</code></i> and <i><code>item</code></i>
    are assumed to be stable and non-volatile, with no alteration occuring to
    them while <code>BinSearch</code> is being carried out.</li>
  <li>
    <p align="left">The operations are clearly stated, but the identification of
    the particular algorithm and preservation of essential conditions is by appeal
    to a separate publication [<a href="#[ACP6.2.1B]">ACP 6.2.1B</a>]</li>
</ul>


</blockquote>


<h2 align="left">1.2 <a name="BinarySearchAlgorithm"> A Binary Search Algorithm</a>
        </h2>


<blockquote>
  <p align="left">To see the difference between the statement of an algorithm for binary search
  and the <code><b>BinSearch</b></code> implementation, we will use the style of
  algorithm presentation introduced by Donald Knuth[<a href="#[Knuth97]">Knuth97</a>:
  1.1]:
        </p>


  <blockquote>


  <p align="left"><b>Algorithm Bin</b> (<i>Binary search</i>).&nbsp; Given a
  list of items <i>K</i><sub>0</sub>, <i>K</i><sub>1</sub>, ..., <i>K</i><sub>N-1</sub><sub><br>
  </sub>in non-decreasing order <i>K</i><sub>0</sub>  <u> &lt;</u> <i>K</i><sub>1</sub> 
  <u> &lt;</u> ··· <u>
  &lt;</u> <i>K</i><sub>N-1</sub>,&nbsp;<br>
 this algorithm finds a position, if any, having a given
  item, <i>K</i>.
        </p>



<dl>
      <dt><b>Bin1.</b> [Initialize.]</dt>
      <dd>Set <i>L</i> to 0; set <i>R</i> to <i>N</i>,<i> </i>the number of
        items.<br>
        (If there are no items, <i>N</i> is 0.)
      </dd>
      <dt>&nbsp;</dt>
      <dt><b>Bin2.</b> [No Luck?]</dt>
      <dd>Let <i>Rem</i> = <i>R</i> - <i>L</i>, the number of eligible items
        remaining.<br>
        If <i>Rem</i> = 0, terminate the search as unsuccessful.<br>
        (Each time we return to Bin2, <i>Rem</i> is smaller and we must
        eventually find a matching item or terminate with all possibilities
        eliminated.&nbsp; See Bin4 and Bin5 to confirm that.)</dd>
      <dt>&nbsp;</dt>
      <dt><b>Bin3</b>. [Take a Look.]</dt>
      <dd>(<i>L</i> &lt; <i>R</i> and if <i>K</i> is among the eligible items
        then <i> K</i><sub><i>L</i></sub> <u>&lt;</u>  <i> K</i> <u>&lt;</u>  <i> K</i><sub><i>R</i>-1</sub>.)<br>
        Set <i>j</i> to floor((<i>L</i>+<i>R</i>)/2).</dd>
      <dd>(<i>j</i> is always an index within one place of the middle of the interval <i>L</i> 
        through <i>R</i>-1.&nbsp; <i>L</i> <u>&lt;</u> <i>j</i> <u>&lt;</u> <i>R</i>-1 always.)<br>
        If <i>K</i><sub><i>j</i></sub> &lt; <i>K</i>, go to Bin4.&nbsp; If <i>K</i>
        &lt; <i>K<sub>j</sub></i>, go to Bin5.<br>
        Otherwise, the search is successful and <i>K</i><i><sub>j</sub></i> is a
        matching item.</dd>
      <dt>&nbsp;</dt>
      <dt><b>Bin4.</b> [Look Higher Next.]</dt>
      <dd>(If <i>K</i> is among the eligible items, then <i>K</i><sub><i>j</i>+1</sub>
        <u>&lt;</u> <i>K</i> <u>&lt;</u> <i>K</i><sub><i>R</i>-1</sub>.)</dd>
      <dd>Set <i>L</i> to <i>j</i>+1.&nbsp; Go to Bin2.<br>
        (0 <u>&lt;</u> <i>R</i> - <i>L</i> &lt; <i>Rem</i>.&nbsp; We have
        eliminated at least half of the current items as ineligible.)</dd>
      <dt>&nbsp;</dt>
      <dt><b>Bin5.</b> [Look Lower Next.]</dt>
      <dd>(If <i>K</i> is among the eligible items, then <i>K<sub>L</sub></i> <u>&lt;</u>
        <i>K</i> <u>&lt;</u> <i>K</i><sub><i>j</i>-1</sub>.)<br>
        Set <i>R</i> to <i>j</i>.&nbsp; Go to Bin2.<br>
        (0 <u>&lt;</u> <i>R</i> - <i>L</i> &lt; <i>Rem</i>.&nbsp; We have
        eliminated at least half of the current items as ineligible.)</dd>
  
</dl>
  </blockquote>
  <p>The statement of the algorithm relies on a supposedly pre-existing framework.&nbsp; We will discuss
  that more in section 2.&nbsp; For now, it is valuable to notice that
  there is an implicit framework and perhaps ponder (1) how much of it we take for
  granted in reading the algorithm and (2) how much the author of this
  description takes for granted about what needs to be said and what it takes to
  understand it.</p>
  <p>This statement of the algorithm is contrived so that someone skilled in the analysis of
  algorithms can independently confirm some important characteristics:</p>
  <ul>
    <li>The preconditions in which the algorithm is assured to operate are
      clearly established</li>
    <li>We rely on&nbsp; mathematical objects, not computational ones, so there
      is a generality beyond the incomplete data representations that arise in
      typical implementations.</li>
    <li>All operations are definite and presumed to be carried out in finite
      time and space.&nbsp; This includes use of floor(<i>x</i>) for the largest
      integer not greater than <i>x</i>.&nbsp;&nbsp;</li>
    <li>At the same time, we are not so definite as to fix the operations in a
      rigid way.&nbsp; It is presumed that there is or can be made to be such a
      fixation when the algorithm is embodied in an implementation.</li>
    <li>No indefinite operations (e.g., reference to <i>K<sub>N</sub></i> or <i>K</i><sub>-1</sub>)
      are ever attempted.</li>
    <li>The algorithm must terminate.</li>
    <li>If the input conditions are satisfied, the algorithm accurately
      determines an index for a <i>K</i>-matching item if and only if there is
      one.&nbsp; The algorithm will terminate unsuccessfully if an only if there
      is no <i>K</i>-matching item.</li>
    <li>One can analyze the performance of the algorithm in terms of the number
      of times step Bin3 is ever performed.</li>
    <li>There is a way of speaking of algorithms as if they exist, yet the
      statements of them are not the algorithms (not unlike the concern we began
      with, involving recognition of algorithms embodied in implementations).</li>
  </ul>
  <p>Also, notice that the annotations made as parenthetical comments are
  not strictly part of the statement of the algorithm.&nbsp; The annotations provide assertions
  about the algorithm that are important in comprehending the achievement of its
  function and of its efficacy.&nbsp; The annotations also support confirmation
  that the recipe given is indeed that of an algorithm for the identified
  function.</p>
  <p style="border-style: double"><i>We are looking here at a few ideas that
  might be worth developing separately:&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp; 1. That the statement of an algorithm has a certain
  looseness to it that is important.&nbsp; Yet it is easy to reach agreement and
  demonstration that there is an interpretation of the statement in an
  implementation that preserves the essentials of the algorithm.<br>
  &nbsp;&nbsp;&nbsp;&nbsp; 2. That implementations can be viewed as
  interpretations of (formal or informal) algorithms<br>
  &nbsp;&nbsp;&nbsp;&nbsp; 3. That the annotations are <b>indispensible</b> to
  the statement of the algorithm and it being seen as satisfying the
  requirements for for accomplishment of the stated purpose with an algorithmic
  solution.</i></p>
  <p style="border-style: double"><i>It will probably be valuable to identify what the
  technical conditions on algorithms are and how
  they are satisfied with this particular example.&nbsp; I don't want to do that
  here.&nbsp; Perhaps in a companion article, or a brief sidebar.</i></p>
  <p style="border-style: double"><i>At some point, we want to nail down this
  way of speaking about the statement of an algorithm, versus the algorithm,
  versus an implementation of the algorithm in a computer program.&nbsp; We want
  to establish that, whatever the difficulties that even the statement of an
  algorithm introduces on &quot;grokking&quot; the algorithm, it is valuable to
  take that route. (2001-02-20)</i></p>
  <p style="border-style: double"><i>Someplace we might talk about focal
  attention versus subordinate intention, the distinctions that Polyani
  introduced concerning language.&nbsp; That and how statements of algorithms
  are methods and there is a relationship to behavior that always has the
  algorithm be &quot;off the paper&quot; and yet something we might see
  ourselves having our focal attention on when we examine the statement of the
  algorithm.&nbsp; (2001-02-20)&nbsp;</i></p>
</blockquote>


  <h2>1.3 <a name="AlgorithmImplementationDance"> Dancing Between Algorithm and Implementation</a></h2>
<blockquote>
  <p align="left">When I am working with statements of algorithms and implementations, I
  toggle back and forth between them.&nbsp; Experiences in developing the
  implementation suggest refinements -- usually simplifications -- to the
  algorithm and its statement that are then reflected by economies in the implementation.&nbsp;
  The process can continue until I am satisfied with the result.&nbsp;&nbsp;<p align="left">When
  I developed <code><a href="#BinSearch">BinSearch</a></code>, I started by
  consulting Knuth's statement of <a href="#[ACP6.2.1B]">Algorithm 6.2.1B</a>.&nbsp; I immediately
  introduced transformations that allowed my preferred style to be expressed in <code><a href="#BinSearch">BinSearch</a></code>,.&nbsp;
  I satisfied myself that none of the transformations sacrificed anything that
  is essential to preserving the algorithm, its correctness, or its
  performance.&nbsp;&nbsp;<p align="left">I did all of this informally, the
  objective at the time being providing an useful worked example of notational
  conventions and their application, not demonstrating algorithmic analysis.<p align="left">In
  questioning whether programs teach algorithms, I took a fresh look.&nbsp;
  Although I again consulted Algorithm 6.2.1B, this time I created Algorithm Bin
  by re-abstraction from BinSearch.&nbsp; I Also restated it in a way where I could
  demonstrate that I had captured everything that there is in Algorithm 6.2.1B,
  and more.<p align="left" style="border-style: double"><i>Discuss how the statement of Algorithm Bin has a pleasant
separation of concerns.&nbsp; It is abstracted completely away from any
application.&nbsp; Contrast this with Knuth's statement, and also with
  Sedgewick's.&nbsp; This is an useful illustration in the abstraction of design
  from algorithm and of algorithm from implementation.&nbsp; (Both Knuth and
  Sedgewich cast the algorithm in the context of a wider purpose.&nbsp; We can
  reflect that in the discussion of design vs. algorithm.)&nbsp; 2001-02-20.</i><p align="left" style="border-style: double"><i><br>
  &nbsp;&nbsp;&nbsp;&nbsp; Talk about why I don't go the final step and
use </i><code><b>while</b> (L != R):</code><i>, leaving the safety cord attached
even when it is demonstrably unnecessary.<br>
  &nbsp;&nbsp;&nbsp;&nbsp; In creating Algorithm Bin as a re-abstraction of </i><b><code>BinSearch</code></b><i>,
  it is not like I walked up with a blank mind and then figured out an
  abstraction that gave me an algorithm I could use.&nbsp; I was certainly aware
  of the function of </i><b><code>BinSearch</code></b><i> and what it was
  intended to accomplish by me, its author.</i><p align="left" style="border-style: double"><i>We can consider decorating code with information about the
algorithm.&nbsp; This might be a form of tangling that has the algorithm carried
with the code so that someone can inspect it as a whole.&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp; The value of that is that the code is tied to the
  algorithmic statement that it provides a valid interpretation of.&nbsp; It
  puts rigor around what the intended function is, and the only knowledge of the
  implementation that it is safe for an user of the implementation to make
  (assuming that one might want to substitute a different implementation that
  preserves the agreed interface and the algorithm).<br>
  &nbsp;&nbsp;&nbsp;&nbsp; If I were to do that, I would want a very clear
  notation for distinguishing discussion about the implementation from the
  annotations that tie the implementation to the algorithm.&nbsp; This might
  make for some wordy code.&nbsp; It would certainly have a valuable
  self-contained property to it.&nbsp; It is apparently not what most
  programmers want to look at.<br>
  &nbsp;&nbsp;&nbsp;&nbsp; I would also want a way of tying implementation
  conditions and restraints, so that the mapping of the algorithm is very clear,
  and the restraints of the implementation are also separately very clear.&nbsp;
  I am thinking of constraints like Bin's L+R being a defined quantity in the operational system of
  the implementation.<br>
  &nbsp;&nbsp;&nbsp;&nbsp; If I attempt this, it will be by coming up with a new
  version of </i><code><b>BinSearch</b></code> <i>here.</i>
</blockquote>
    <h1 align="left">2. <a name="AlgorithmicBaggage"> Algorithmic Baggage</a></h1>
<blockquote>
  <p align="left" style="border-style: double"><i>Point out that we pretty much always say more than is
essential.&nbsp; And it is still important to have a form of expression that has
it be understood that the algorithm is definitely and always more abstract than
the implementation.<br>
  &nbsp;&nbsp;&nbsp;&nbsp; Every expression of an algorithm has baggage.&nbsp;
  This includes assumptions about the existence of orderings, the assumption of
  0-origin indexing, the use of natural numbers for indexes, and the
  stability of the objects involved.&nbsp; That the algorithm is effectively carried out
  atomically, while itself being composed of definite steps, is a key assumption
  in almost all expression of algorithms.&nbsp; This is part of the framework.<br>
  &nbsp;&nbsp;&nbsp;&nbsp; Then there is the simple use of ordinary language
  along with borrowing of mathematical objects and notations, all more framework
  for expressing algorithms.&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp; The value of using ordinary language and distinct
  notations from that for program code must not be underestimated.&nbsp; It
  gives us a way of distinguishing the two, and of being able to establish what
  is essential and what is incidental (but perhaps inescapable baggage) of the
  given implementation.&nbsp; We can also begin to separate the baggage of the
  algorithmic framework and the baggage of the implementation system.<br>
  &nbsp;&nbsp;&nbsp;&nbsp; It is important that we appreciate the value of
  having more than one perspective on this.&nbsp; It gives us a place to
  separate problem from solution, and be clear which is a statement of
  what.&nbsp; the algorithm-implementation separation contributes to the
  separation of the abstraction from the statements of it.&nbsp;&nbsp;</i>
</blockquote>
    <h1 align="left">3. <a name="AbstractingAlgorithms"> Abstracting Algorithms</a></h1>


<blockquote>


<p align="left" style="border-style: double"><i>Consider that the level of abstraction
for statements of algorithms might
need to be improved.&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp; One way is to notice that the objects appealed to in
the statement of the algorithm might be at the wrong level.&nbsp; A large part
of the baggage in our example is related to the level at which we deal with
ordered lists via indexes.&nbsp; There might be a way to change the level such
that we address lists in other terms that are somehow liberated from the baggage
about indexes and their origins.&nbsp; It might be a quite different algorithm,
assuming quite different basic operations, and we won't go there.<br>
&nbsp;&nbsp;&nbsp;&nbsp; Another approach is to make reliance on abstract
elements explicit rather than tacit.&nbsp; What we might get to is a form of
expression of algorithms that can be taken as concrete, given a representation
of the abstract elements.&nbsp;&nbsp;</i>
        </p>


<p align="left" style="border-style: double"><i>
&nbsp;&nbsp;&nbsp;&nbsp; We are always going to have algorithmic baggage.&nbsp; Can we
arrange baggage in such a way that the baggage is understandable and the
abstracted algorithm is pretty clear?&nbsp; We take a look at a toy case using
an abstract structure for the bit.<br>
&nbsp;&nbsp;&nbsp;&nbsp; This might be better described as <b>concretizing
abstractions</b>.&nbsp; That is, we want to make the subject-matter of the
algorithm, the structures that are understood, explicitly abstracted so that we
can see what the dependencies are.&nbsp; To do this, we still need a framework,
but one that makes explicit that which was originally tacit.&nbsp; (2001-02-20)</i>
        </p>


  <p align="left" style="border-style: double">The bit abstraction began as an
  exercise early in the original Miser Project when I began to look at how to
  abstract out data types from algorithms, and look at the kind of automatic
  program transformations that become available as a consequence.&nbsp; The
  title for this is <i>Homage to the Bit</i>, and I fancy publishing it in <i>BIT</i>,
  on some anniversary occasion.&nbsp; Here is a sketch, with the full treatment
  better done in its own paper.&nbsp; I will put enough in this article to
  expand on the problem of baggage and what one must deal with to &quot;deliver
  abstractions&quot; into the concrete world of a programming system.<br>
  &nbsp;&nbsp;&nbsp;&nbsp; 1. Consider that we arrange a way for data types to
  always be typical of their class.&nbsp; We won't expand on that here, just
  introduce it as the adopted approach.&nbsp; We want to introduce concrete data
  types that have certain qualities that preserve abstractness in some useful
  and extremely practical sense.&nbsp; In particular, the implementations are
  fully substitutable, and this can be done selectively and anywhere in a
  computational method.&nbsp; We illustrate this idea by presenting a &quot;concrete
  abstraction&quot; for one of the most fundamental data types of all, the
  binary bit.<br>
  &nbsp;&nbsp;&nbsp;&nbsp; 2. For example, when <i><code>b</code></i> is an <b><i><code>01bit</code></i></b>
  (read &quot;oh-one-bit&quot;) then <code><i>b</i>.0</code> is the 0-bit and <code><i>b</i>.1</code>
  is the 1-bit.&nbsp; If we have an <b><i><code>01bit</code></i></b>, we can get
  any <b><i><code>01bit</code></i></b> we want.&nbsp; Every instance is typical
  of the class.&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp; 3. Notice how much framework we are heaping on this
  very simple notational invention.&nbsp; I mean some <b><i><code>01bit</code></i></b>,
  <i><code>b</code></i>, and I specify features of <code><i><b>01bit</b></i></code>s
  by using the <code>.</code>-notation.&nbsp; That is, the <code>0</code>
  feature, <code><i>b</i>.0</code>, is the 0-bit of <b><i><code>01bit</code></i></b>s,
  and the <code>1</code> feature, <code><i>b</i>.1</code>, is the 1-bit of <b><i><code>01bit</code></i></b>s.&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp; 4. Don't worry about this too much.&nbsp; This is not an ordinary way of
  speaking, and the notation is used in a critical way.&nbsp; Just look and
  notice how we are using ordinary language to talk about a concrete
  (implemented) thing, and what it takes for us to be rigorous in doing
  that.&nbsp;&nbsp;Also notice that almost everything is in our (framework)
  language.&nbsp; What makes these concrete abstractions, in our way of speaking
  here, is that we have a rigorous (formal) framework language that allows us to
  say all there is that can be discerned about some things.&nbsp; They have some
  concrete existence, lets suppose, but we are only able to &quot;see&quot; them
  as if there is an actual abstraction there.&nbsp; That is, the framework
  guarantees that we don't get to see (in the framework context) anything more
  than the abstraction.&nbsp; Now, notice how this is not entirely true.&nbsp;
  For one thing, the idea of bits is extremely simple.&nbsp; What we have here
  is a pretty elaborate framework so we can talk about them as if they are
  something that can be talked about!&nbsp; Basically, <b><i><code>01bit</code></i></b>s
  are concrete abstractions that have two distinct individuals.&nbsp; The one we
  call the 0-bit is designated <code><i><b>01bit</b></i>.0</code>.&nbsp; The one
  we call the 1-bit is designated <code><b><i>01bit</i></b>.1</code>.&nbsp; And
  the way that we have of telling whether the one we have in hand, <i><code>b</code></i>,
  is the 0-bit or not is by the designation <code><i>b</i>.is-0</code>.&nbsp;
  Notice that almost everything in the framework is about how we are going to
  designate individuals and tell which one is at hand, so to speak.&nbsp; Our
  biggest job is agreement on language and terminology.&nbsp; (2001-02-21)<br>
  &nbsp;&nbsp;&nbsp;&nbsp; 5. Even at this point, you don't have any assurance
  that <b><i><code>01bit</code></i></b>s have anything to do with our everyday
  notion of bits other than I have said so.&nbsp; That is, there are 0-bits,
  1-bits, and they are different.&nbsp; That's about all there is to bits.&nbsp;
  It doesn't even matter how I pick one <code><i> <b>01bit</b></i></code>
  individual to be
  the 0-bit and the other to be the 1-bit, so long as I keep it all
  straight.&nbsp; This is important: there are syntactic features that allow
  us to converse about bits and think we know what we are talking about.&nbsp;
  It happens that the choice of feature is arbitrary, although it must be fixed.&nbsp; (The
  notion of the dual of Boolean algebras lurks in here.&nbsp; We'll not go into that
  here.)&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp; 6. I am saying that to come up with a concrete
  abstraction, we need to fix the features and their expression.&nbsp; The
  labels don't matter, the discrimination among the features and any specific
  behavioral conditions are what matter.&nbsp; So much baggage.&nbsp; So few
  bits.<br>
  &nbsp;&nbsp;&nbsp;&nbsp; 7. When we have an <b><i><code>01bit</code></i></b>, how do we know which bit we
  have?&nbsp; We have to take a position about that to be able to operate with
  these objects.&nbsp; We could take a common approach and introduce a
  proposition that applies to all bits: <code><i>b</i>.is-0</code>.&nbsp; The
  framework assumption here is that we have some notion of truth or, at the very
  least, are able to deal conditionally with the answers to questions.&nbsp;
  This is pretty fundamental for algorithmic frameworks, so we'll go with <code><i>b</i>.is-0</code>.&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp; 8. There is a metaquestion here too.&nbsp; How do I
  know that I have an <b><i><code>01bit</code></i></b> at hand?&nbsp; Hold that
  thought.&nbsp; (2001-02-20)<br>
  &nbsp;&nbsp;&nbsp;&nbsp; 9. <code><i>b</i>.is-0</code> works for <b><i><code>01bit</code></i></b>s
  because in our ordinary notion of binary bits, a given bit is either the 0-bit
  or it isn't, and if it isn't it must be the 1-bit.&nbsp; The use of a specific
  proposition is a little inconvenient when generalizing to more-interesting
  finite sets, and we will ultimately prefer to introduce some equality
  determination for members of abstractions like <b><i><code>01bit</code></i></b>s.&nbsp;
  Either way, we are making even more framework assumptions.&nbsp; For now, <code><i>b</i>.is-0</code>
  works just dandy.
        </p>


<p align="left" style="border-style: double">Now, if I presented you with a
  programming system's fixed data type, <b><code>01bit</code></b>,&nbsp; and
  said these are (representations of) the binary bits and here's a notation for
  specifying them and examining them, I wouldn't have done much.&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp; 1. I would have presented you with an implementation
  that has an intended interpretation as binary bits.&nbsp; It might even have
  the intended pragmatic interpretation of corresponding to the binary bits of
  an underlying computational mechanism with the assurance that these bits
  correspond to the bits in the memory system of that mechanism.&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp; 2. I want to do something different than that.&nbsp;
  The <b><i><code>01bit</code></i></b>s are intended to be concrete
  abstractions, and we don't want to lose the abstractness of it.&nbsp; There
  might be some flavor of <code><i><b>01bit</b></i></code> that has all of that
  connection to a predictable and known implementation.&nbsp; But that is not to
  be assumed of <b><i><code>01bit</code></i></b>s generally.<br>
  &nbsp;&nbsp;&nbsp;&nbsp; 3. Here is a Python-flavored function using <b><i><code>01bit</code></i></b>s:<br>
  <br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>def</b> 01and(<i>a</i>:
  <i><b>01bit</b></i>, <i>b</i>: </code><b><i><code>01bit</code></i></b><code>) </code><b><i><code>01bit</code></i></b><code>:<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <b>if</b> <i>a</i>.is-0:<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <b>return</b> <i>a</i><br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <b>else:<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  return</b> <i>b<br>
  <br>
  </i></code>Although I would never expect to be able to say this in Python (it
  not being in the spirit of the language), I am using this form for contrast
  and to have an existing framework.&nbsp; This is also an imperfect model, so
  take it as merely exemplary.<br>
  &nbsp;&nbsp;&nbsp; 4. What I want to suggest is programming-system machinery
  where the <code>01and</code> function is understood as the expression of an
  algorithm as much as that is possible in a concrete programming system.&nbsp;
  In particular, this definition does not depend on a fixed sense of <b><code>01bit</code></b>,
  but simply requires delivery of <b><code><i>01bit</i></code></b>s --
  parameters that have the features of <b><i><code>01bit</code></i></b>s and
  that satisfy whatever conditions exist for a concrete flavor to satisfy the
  abstraction.<br>
  &nbsp;&nbsp;&nbsp; 5. It might be more general to suggest the following
  notation, not unlike the template notion of some languages:<br>
  <br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>def</b> 01and(<i>bit</i>:
  <b><i>01bit</i></b>)(<i>a</i>: <i>bit</i>, <i>b</i>: </code><i><code>bit</code></i><code>)
  </code><i><code>bit</code></i><code>:<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <b>if</b> <i>a</i>.is-0:<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <b>return</b> <i>a</i><br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <b>else:<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  return</b> <i>b<br>
  </i><br>
  </code>This might provide a stronger sense of what is intended.&nbsp; I am
  concerned that this implies too much and I am not wedded to this
  approach.&nbsp; So far.<br>
  &nbsp;&nbsp;&nbsp;&nbsp; 6. I haven't said how one defines <b><code><i>01bit</i></code></b>
  in this kind of system.&nbsp; I'm not prepared to make a commitment to that,
  which is my nice way of saying I haven't figured it out yet.<br>
  &nbsp;&nbsp;&nbsp;&nbsp; 7. What you can count on is that if any <i>a</i> and <i>b</i>
  are supplied that do not satisfy the conditions for the concrete abstraction, <i>bit</i>,
  then the function fails.&nbsp; It doesn't return a result, it fails.&nbsp;
  Furthermore, if the implementation of the function returns a result, it is
  assured to satisfy the concrete abstraction, <i>bit</i>.<br>
  &nbsp;&nbsp;&nbsp;&nbsp; 8. Given this function, <code>01and</code>, assume
  that the programming system allows ways that one can cast an existing object
  that has the necessary qualities of a <i>bit</i> as an <b><code><i>01bit</i></code></b>.&nbsp;
  That is, one does not have to be content with arranging things to be <b><code><i>01bit</i></code></b>s
  before they are useable in operations defined on <b><code><i>01bit</i></code></b>s.&nbsp;
  We could instead define an <b><i><code>01bit</code></i></b> over some other
  type, lets say <b><i><code>Boolean</code></i></b>,&nbsp; in which we specify
  how the features of an <b><code><i>01bit</i></code></b> are derived from the
  features of a <b><i><code>Boolean</code></i></b>.&nbsp; This gives an
  interpretation of a <b><i><code>Boolean</code></i></b> as an <b><i><code>01bit</code></i></b>.&nbsp;
  Generally, there are many ways to do this, so we might want to name particular
  interpretations or use a descriptive notation in which we show the particular
  interpretation.&nbsp; Suppose we use the name <b><code><i>Boolean01bit</i></code></b>
  for the interpretation that has <b><code>true</code></b> be the 1-bit and <b><code>false</code></b>
  be the 0-bit.&nbsp; Then <code><b><i>Boolean01bit</i></b>(<b><i>Boolean</i></b>.true)</code> is <code><b><i>01bit</i></b>.1</code>.&nbsp;
(2001-02-20)<br>
&nbsp;&nbsp;&nbsp;&nbsp; 9. There's something I want to add here, but I have
forgotten it for the moment. It is about how all we are talking about is the
features of some hidden thing, a concrete thing that we only want to see in
accordance with an abstraction that it supports.&nbsp; We are, let us say, using
these concrete abstractions as attributive views onto something.&nbsp; The
something is the concrete part.&nbsp; The abstraction is what we have when we
only allow those particular attributions to be seen as the features.&nbsp; The
validity of the concrete abstraction is that its behavior never contradicts the
abstraction.&nbsp; In computing terms, we would talk about hiding an
implementation.&nbsp; In logic, we would say that we have a valid interpretation
of the abstraction.&nbsp; (2001-02-21)<br>
  &nbsp;&nbsp;&nbsp;&nbsp; 10. There can be ways to cast values from <b><i><code>01bit</code></i></b>
  to <b><i><code>Boolean</code></i></b>, and this means that the result of <code>01and</code>
  can be made into a <b><code><i>Boolean</i></code></b> without much difficulty.&nbsp;
For example, <code><b><i>01bitBoolean</i></b>(<b><i>01bit</i></b>.1)</code>
could be <code><b><i>Boolean</i></b>.true</code>.<br>
&nbsp;&nbsp;&nbsp; 11. I am messing with the typography here.&nbsp; I am not
quite prepared to concede that <code><b><i>Boolean01bit</i></b></code> and <b><code><i>01bitBoolean</i></code></b>
are regular functions (with regard to whatever functions are in the framework),
so I have used <b><i>special typograhy</i></b> in their names.&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp; 12. It can appear, at this point, that we haven't done
anything.&nbsp; That is, We have made explicit a way to use <code><i><b>01bit</b></i></code>s
as <b><code><i>Boolean</i></code></b>s and <b><i><code>Boolean</code></i></b>s
as <b><code><i>01bit</i></code></b>s.&nbsp; Aren't we just stating the
obvious?&nbsp; Exactly so.&nbsp; We have made explicit what, in some frameworks,
is not only taken as tacit, but it might not even be recognized that such is
being done -- that there is any other way to look at it.&nbsp; Until I told you
that the definitions of <b><code><i>Boolean01bit</i></code></b> and <b><code><i>01bitBoolean</i></code></b>
were the obvious ones, I say it wasn't obvious yet.&nbsp; One could jump to
those conclusions, but there is no basis in anything said up to this
point.&nbsp; (2001-02-20)<br>
&nbsp;&nbsp;&nbsp;&nbsp; 13. Here's the next piece of information.&nbsp; All
there is to know about <code><b><i>01bit</i></b></code>s is what you've been
told here.&nbsp; That is, the only known features are <code><b><i>01bit</i></b>.0</code>,
<code><b><i>01bit</i></b>.1</code>, and <code><b><i>01bit</i></b>.is-0</code>.&nbsp;
All that is implied for <b><i><code>Boolean</code></i></b>s, so far, is that
there are <code><b><i>Boolean</i></b>.true</code> and <code><b><i>Boolean</i></b>.false</code>.&nbsp;
One might suppose that there is also a <code><b><i>Boolean</i></b>.is-false</code>,
in which case our suspicions about there being no difference here, other than a
choice of labels, are difficult to resist.&nbsp; However, that there is such a
prospect is different than it being so.&nbsp; And we have not said whether there
are <i>only</i> these features of <code><i><b>Boolean</b></i></code>s.&nbsp; In
fact, I assert that there is no <code><b><i>Boolean</i></b>.is-false</code> as
part of the definition for <b><i><code>Boolean</code></i></b>s.&nbsp; There is,
however, a <code><b><i>Boolean</i></b>.is-true</code>.&nbsp; (Notice that we
still haven't said what kind of object is determined by the <b><i><code>01bit</code></i></b>.is-0
and <b><i><code>Boolean</code></i></b>.is-true features.) (2001-02-20)<br>
&nbsp;&nbsp;&nbsp;&nbsp; 14. Here's a little more.&nbsp; Let <b><i><code>N</code></i></b>
be a concrete abstraction for the natural numbers (or at least the Peano
numbers).&nbsp; Feature <code> <b><i>N</i></b>.0</code>
is the zero or origin of the naturals, <b><i><code>N</code></i></b><code>.s</code>
is the successor of whatever natural number that an <b><i><code>N</code></i></b>
represents, and <b><i><code>N</code></i></b><code>.p</code> is the predecessor
of whatever natural number an <b><i><code>N</code></i></b> represents.&nbsp; It
happens that <code><b><i>N</i></b>.0.p</code> is always <code><b><i>N</i></b>.0</code>
in this formulation.&nbsp; Finally, <code><b><i>N</i></b>.is-0</code> is defined
analogously to <code><b><i>01bit</i></b>.is-0</code>.&nbsp; That is all there is
to know about <b><i><code>N</code>'</i></b>s.&nbsp; It is <i>useful</i> to
introduce <b><code><i>BooleanN</i></code></b> so that <code><b><i>BooleanN</i></b>(<i><b>N</b></i>.0)</code>
is <code><b><i>Boolean</i></b>.false</code> and <code><b><i>BooleanN</i></b>(<b><i>N</i></b>.s)</code>
is <code><b><i>Boolean</i></b>.true</code>.&nbsp; Likewise, <code><i><b>NBoolean</b></i>(<b><i>Boolean</i></b>.false)</code>
is <code><b><i>N</i></b>.0</code> and <code><i><b>NBoolean</b></i>(<i><b>Boolean</b></i>.true)</code>
is <code><i><b>N</b></i>.0.s</code>.&nbsp; (2001-02-20)
        </p>


<p align="left" style="border-style: double">&nbsp;&nbsp;&nbsp;&nbsp; 1. It may
seem that <b><i><code>Boolean</code></i></b>s and <b><code><i>01bit</i></code></b>s
are not much different and they could be defined to be the same or equivalent in
some way.&nbsp; While it might be useful to do that, I am intentionally avoiding
doing so here.&nbsp; Where we to do that, there is still no such obvious
equivalence between <b><i><code>Boolean</code></i></b>s and <b><i><code>N</code></i></b>'s,
even though the interpretations <b><i><code>BooleanN</code></i></b> and <b><i><code>NBoolean</code></i></b>
are very useful in practice (and are tacitly employed in the C programming
language and its relatives.)<br>
&nbsp;&nbsp;&nbsp;&nbsp; 2. I am going to make a framework commitment now.&nbsp;
Suppose that features <code><b><i>01bit</i></b>.is-0</code>, <code><b><i>Boolean</i></b>.is-true</code>,
and <code><b><i>N</i></b>.is-0</code> are all <b><i><code>Boolean</code></i></b>s.&nbsp;
I immediately no longer require <code><b><i>Boolean.</i></b>is-true</code> and
one might plausibly claim that <b><code><i>Boolean</i></code></b>s are now more
primitive and essential than <b><i><code>01bit</code></i></b>s.&nbsp; The
algorithmic framework inherently depends on <b><i><code>Boolean</code></i></b>s.&nbsp;
It is what we use to be specific about having the answer to a question and being
able to operate conditionally with that answer.<br>
&nbsp;&nbsp;&nbsp;&nbsp; 3. One can argue that ensnarling the framework with a
commitment to a particular concrete abstraction for choice is unnecessary and
also inconsistent with the idea of carefully managing the choice of
abstractions.&nbsp; It is the case that the statement of algorithms depends
almost always on having a way to distinguish particular objects and vary the
progression of operations based on that.&nbsp;&nbsp; But this need not be the
best way to deal with it.&nbsp; That is not important for this discussion.&nbsp;
The point here is how things can fall into place when one makes such a
commitment.&nbsp;&nbsp; It is also the case that there is an underlying
commitment that becomes invisible while shaping the statement of
algorithms.&nbsp; (2001-02-20)<br>
&nbsp;&nbsp;&nbsp;&nbsp; 4. In thinking about whether we collapse the truth
system of the framework with <b><code><i>Boolean</i></code></b> or not, I
realize there is a similar concern with regard to explicit identity.&nbsp; I
defined these concrete abstractions using is- features, avoiding having an
explicit identity (and the messiness of binary operations, which I didn't want
to drag in).&nbsp; On the other hand, natural formulations of axiomatic theories
for structures <b><i><code>Boolean</code></i></b>, <b><i><code>01bit</code></i></b>,
and <b><i><code>N</code></i></b>, all appeal to some identity function.&nbsp; I
could look to see how to avoid use of identity there, but I don't see how to
avoid it, especially for <b><i><code>N</code></i></b>.&nbsp; I am becoming more
inclined not to collapse any framework structure with these (supposedly)
concrete structures.&nbsp; I will also have to cure myself of the idea of
concrete abstractions, finding better terminology.&nbsp; (2001-02-21)
        </p>


<p align="left" style="border-style: double">What's the point of all of
  this?&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp; 1. First, making abstractions concrete (i.e.,
  executable or performable) does not free us from baggage.&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp; 2. Secondly, making the baggage explicit leads to
  something very unfamiliar, though potentially very useful.&nbsp;&nbsp;&nbsp;
One useful consequence is that we need not use a concrete abstraction any more
powerful than the situation requires.&nbsp; When all that is needed is some sort
of <b><i><code>Boolean</code></i></b> or <b><code><i>01bit</i></code></b>, we
can use just that.&nbsp; When all we need to do is count up and down, <b><i><code>N</code></i></b>'s
can be the most direct.&nbsp; This lets us get <i>closer</i> to what's essential
to the situation, at the expense of being much more rigorous about the features
that we depend upon.&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp; 3. It is not clear that combining all of this in one
  system is an easy way to get to programming or algorithms.&nbsp;&nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp; 4. This approach does point out how much about
  computation is about choosing a data representation.&nbsp; This is one of
  those aspects of software development that is done unconsciously, and putting
  attention on this via discussion of concrete abstractions (i.e.,
  highly-disciplined data representations that have pretensions to delivery of
  abstractions) is an useful investigation.<br>
  &nbsp;&nbsp;&nbsp;&nbsp; 5. I wouldn't want to give up on separation of
  design, algorithm, and implementation in favor of machinery like this.&nbsp; I
  don't think machinery like this is very understandable until one has gone
  through practical experiences that foster differentiation and abstraction of
  design, algorithm, and implementation.
        </p>


</blockquote>


    <h1 align="left">4. <a name="SeparatingAlgorithmImplementationDesign"> Separating Algorithm, Implementation, and Design</a></h1>


<blockquote>


<p align="left" style="border-style: double"><i>We then look at what may well be the likely case in a
practical situation.<br>
&nbsp;&nbsp;&nbsp;&nbsp; 1. We confess that we came in with a point of view about
conceptual abstractions, and make the best of it.<br>
&nbsp;&nbsp;&nbsp;&nbsp; 2. We look at the motivation for doing this, and why we
don't want to collapse algorithms and implementations together.&nbsp; Part of it
has to do with coming to grips with what is essential.&nbsp; We have a practical
example of what is available when we bother to do that.&nbsp; (I have another
example in the Dr. Dobb's paper on integer powers.)<br>
&nbsp;&nbsp;&nbsp;&nbsp; 3. There is also an example in why we often do applied
mathematics the way we do, whether balancing a checkbook or building a table or
playing pool or pitching at baseball, when we bother to look at these activities
that way.</i>
        </p>


<p align="left" style="border-style: double"><i>There is an example of design
versus algorithm in what we want to represent versus how we are representing it
(algorithmically).&nbsp; Also, the combination of algorithms that go into the
design of something can have algorithms at a quite different level of
abstraction than that of the design.</i>
        </p>


</blockquote>


<h2 align="left"><i><a name="References">References</a></i>
        </h2>


<blockquote>


<dl>
 
    <dt><a name="[ACP6.2.1B]">[ACP 6.2.1B]</a></dt>
    <dd>Knuth, Donald E.&nbsp; Binary Search.&nbsp; Algorithm 6.2.1B on p. 410
      of <i><a href="../compsci.htm#[Knuth98b]">The Art of
      Computer Programming</a></i><a href="../compsci.htm#[Knuth98b]">,
      <i>v.3: Sorting and Searching</i></a>.&nbsp; ed.2.&nbsp; Addison-Wesley
      Longman (Reading, MA: 1998).&nbsp; ISBN 0-201-89685-0.&nbsp;&nbsp; <font size="-1"><b>&nbsp;&nbsp;&nbsp;&nbsp; <code><br>
      </code>&nbsp;&nbsp;&nbsp;&nbsp; <code><a href="#BinSearch">BinSearch</a></code></b>
      is derived from the form given by Knuth in <i>Scientific American</i> <b>236</b>,
      4 (April 1977), as reprinted on pp.66-67 of <i><a href="../compsci.htm#[Knuth96]">Selected
      Papers on Computer Science</a>,</i> CSLI (Palo Alto: 1996),&nbsp; ISBN
      1-881526-91-7 pbk.<br>
      &nbsp;&nbsp;&nbsp;&nbsp; This <b><a href="#BinSearch"><code>BinSearch</code></a></b>
      is adjusted to avoid wondering what <code><b><i>m</i>/2</b></code> might
      be for integer <b><code><i>m</i>&lt;0</code></b>, while preserving a clean
      terminating condition and loop invariant.&nbsp; It is required that <b><code>(2*<i>i</i>+1)/2</code></b>
      be <i><code><b>i</b></code></i>
      for non-negative <b><i><code>i</code></i></b>.</font></dd>
 
    <dt>&nbsp;</dt>
      <dt><a name="[Knuth97]" href="../compsci.htm#[Knuth97]">[Knuth97]</a></dt>
      <dd>Knuth, Donald E.&nbsp; <i><a href="../compsci.htm#[Knuth97]">The Art of Computer
        Programming, vol.1:
        Fundamental Algorithms</a></i>. ed.3.&nbsp; Addison Wesley Longman (Reading,
        MA: 1997).&nbsp; ISBN 0-201-89683-4.</dd>
 
    <dt>&nbsp;</dt>
      <dt>[<a name="Polya57" href="../math.htm#[Pólya57]">Pólya57</a>]</dt>
      <dd>Pólya, George.&nbsp; <i>How to Solve It</i>.&nbsp; ed.2.&nbsp;
        Princeton University Press (Princeton, NJ: 1945, 1957).&nbsp; ISBN
        0-691-08097-6.</dd>
      <dt>&nbsp;</dt>
 
    <dt><a name="[Sedgewick89]" href="../compsci.htm#[Sedgewick89]">[Sedgewick89]</a></dt>
    <dd>Sedgewick, Robert.&nbsp; <i>Algorithms</i>.&nbsp; Second edition.&nbsp;
      Addison-Wesley (Reading, MA: 1983, 1988).&nbsp; 1989 reprint with authors
      corrections.&nbsp; ISBN 0-201-06673-4.</dd>
 
</dl>


<hr>

</blockquote>


<h3 align="left"><i><a name="History">History</a></i></h3>

<blockquote>
  <dl><font size="-1">
      <dt><b><a name="0.15">0.15</a> 2001-02-23 Split off as <a href="r010101a.htm">R010101a</a>
        to preserve the raw notes</b> (orcmid).</dt>
      <dd>This version is the original 0.10 renamed and titled.&nbsp; The
        intention is to leave it alone and continue expansion of the themes here
        in separate <a href="http://miser-theory.info/notes/">notes</a> of the <a href="http://miser-theory.info/" target="_top">Miser
        Project</a>.&nbsp;&nbsp;</dd>
      <dt><b><a name="0.10">0.10</a>  2001-02-23 Prepare <a href="r010101.htm">R010101</a>
        for division into
        separate articles</b> (orcmid).</dt>
      <dd>This note becomes the common basis for several articles
        that address the underlying themes more carefully.</dd>
      <dt><b><a name="0.00">0.00</a> 2001-01-04</b> <b>Initiate &quot;<a href="r010101.htm">Do
        Programs Teach Algorithms?</a>&quot;</b> (orcmid)</dt>
      <dd>On re-examinination of&nbsp; Sedgwick's <i><a href="#[Sedgewick89]">Algorithms</a></i>,
        I noticed that there seems to be a <a href="#review">collapse</a> of
        algorithms with their implementations, and that algorithms are not
        directly addressed.&nbsp; This reminded me of earlier work,
        &quot;Programs Are Rarely Algorithms&quot; that I'd discussed with Bill
        Anderson in the 80's.&nbsp; It seemed important to speak up about it
        here, especially in light of my inquiry into &quot;concrete
        abstractions.&quot;</dd>
  </font></dl>
</blockquote>

<p align="right"><font size="-2">created 2001-01-04-12:40 -0800 (pst) by <a href="../../construction/orcmid.htm"> orcmid</a><br>
<em>$$Author: Orcmid $<br>
$$Date: 02-10-13 12:49 $<br>
$$Revision: 15 $</em></font></p>

</body>
</html>
