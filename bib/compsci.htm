<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Language" content="en-us">
<meta name="GENERATOR" content="Microsoft FrontPage 6.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>Computer Science Bibliography</title>
<!--$$Header: /OrcmidCompagno/readings/compsci.htm 84    22-05-06 12:12 Orcmid $-->
<base target="_self">
</head>

<body stylesrc="../construction/templates/00/c000005e.htm" bgcolor="#FFFFFF" text="#000080" link="#0000FF" vlink="#800080" alink="#FF0000">

<table border="0" width="100%" height="3">
  <tr>

<font face="Arial, Microsoft Sans Serif, Helvetica, Geneva, Swiss, Sans Serif">

    <td width="20%" height="6" valign="middle">

<font face="Arial, Microsoft Sans Serif, Helvetica, Geneva, Swiss, Sans Serif">
	<!--webbot bot="Include" U-Include="../construction/templates/00/c000007b.htm"
      TAG="BODY" startspan -->
<a href="../bib" target="_top">
<img border="0" src="../images/F23xy102-2023-09-05-1601-MyBookCase.png" width="160" height="209" alt="Shelves of Technical Books" longdesc="2023-09-05 Photograph of shelves of one of Orcmid's bookcases"></a><a href="http://orcmid.com" target="_top">
<!-- Included from construction/templates/00/c000007b.htm of 2023-09-07-19:38Z --></a>
<!--webbot bot="Include" i-checksum="1449" endspan --></font></td>

    <td width="53%" height="6">
	<p align="center">

<font face="Arial, Microsoft Sans Serif, Helvetica, Geneva, Swiss, Sans Serif">
	<strong><a href="../">
	<font color="#993333">Bibliographies</font></a><font color="#990033"><br>
      </font>
      <i><font size="5" color="#993333">Computer Science</font></i></strong></font></td>
    <td width="27%" height="6">
      <p align="right"><b><code><a href="../" target="_top">orcmid.github.io</a>&gt;<br>
      <a target="_top" href="./">bib</a>&gt;</code></b></p>

<font face="Arial, Microsoft Sans Serif, Helvetica, Geneva, Swiss, Sans Serif">
		<div align="right">
			<!--webbot bot="Include" U-Include="../construction/templates/00/c000006b1.htm" TAG="BODY" startspan -->
		
		<table border="0" width="24%" style="border-collapse: collapse" id="ClustrMap">
		<caption align="bottom" valign="bottom"><small><small>
				<a href="../construction/templates/00/c000006.htm">visits to <b>Orcmid on GitHub</b></a></small></small></caption>
			<tr>
				<td>
				<p align="center">
			<small>
			<font color="#707070" face="Arial, Microsoft Sans Serif, Helvetica, Geneva, Swiss, Sans Serif">

				<a href="https://clustrmaps.com/site/1bw9w" title="Visit tracker"><img src="//www.clustrmaps.com/map_v2.png?d=3-2eQV4fOuelVHp_YtztZ0hl9Uj4ei9zLKw_nRgCgyM&cl=ffffff"></a>
				</font></small></td>
			</tr>
			<!-- Inserted from orcmid.github.io/construction/templates/00/c000006c1.htm of 2023-09-10T18:34Z -->
		</table>
	
	<!--webbot bot="Include" i-checksum="23720" endspan --></div>
</font>

      <p align="right"><b><code><a target="_top" href="compsci.htm">compsci</a>&gt;</code></b><br>
      <small><small>
		<!--webbot bot="Timestamp"
      S-Type="EDITED" S-Format="%Y-%m-%d" startspan -->2025-12-05<!--webbot bot="Timestamp" i-checksum="12172" endspan -->                     
      -<!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%H:%M %Z" startspan -->15:24 -0800<!--webbot bot="Timestamp" i-checksum="12011" endspan -->              
      </small></small></p></td>
</font>

  </tr>
</table>

<blockquote>
  <blockquote>
    <dl>
      <dt><b><i>&nbsp;&nbsp; </i></b></dt>
		<dt><b><i>see also:</i></b></dt>
      <dd><b>Readings in <a href="pc.htm">Personal Computing</a><br>
        Readings in <a href="softools.htm">Software Tools</a>  
        </b></dd>
      <dt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Readings in <a href="infoware.htm">Information               
        Processing</a></b></dt>
      <dd><b>Readings in <a href="swe.htm">Software Engineering  
        </a>
        </b></dd>
      <dd><b>Readings in <a href="sysarch.htm">System Architecture and Design<br> 
        </a>
        Readings in <a href="progsys.htm">Programming Systems and Languages</a></b></dd> 
      <dd><b>Readings in <a href="funprog.htm">Functional
        Programming Systems</a></b></dd>
    </dl>
  </blockquote>

</blockquote>

<hr color="#000080">

          
            
    <dl>           
      <dt>[<a name="Ashenhurst1987" href="#Ashenhurst1987">Ashenhurst1987</a>]</dt>           
      <dd>Ashenhurst, Robert L., Graham, Susan L. (eds.).&nbsp; <i>ACM Turing Award                                                  
        Lectures: The First Twenty Years 1966-1985</i>.&nbsp; ACM Anthology                                                  
        Series.&nbsp; ACM Press (New York: 1987).&nbsp; ISBN 0-201-07794-9.<small><br>                                                 
        &nbsp;&nbsp;&nbsp;&nbsp; The <a href="http://www.acm.org/awards/taward.html" target="_top">complete                                            
        list</a> is maintained on the <a href="http://www.acm.org/" target="_top">ACM web site</a>.</small></dd>                                               
      <dd><small>            
        &nbsp;&nbsp; Content<br>                                                 
        &nbsp;&nbsp;&nbsp;&nbsp; Author's Biographies<br>                                                
        &nbsp;&nbsp;&nbsp;&nbsp; Preface<br>                                                
        &nbsp;&nbsp;&nbsp;&nbsp; Introduction to Part I Programming Languages                                                 
        and Systems (Susan L. Graham)<br>                                                
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1966 The                                                 
        Synthesis of Algorithmic Systems (Alan J. Perlis)<br>                                                
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1972 The Humble                                                 
        Programmer (Edsger W. Dijkstra)<br>                                                
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1974 Computer                                                 
        Programming as an Art (Donald E. Knuth [<a href="#[Knuth1974]" target="_self">1974</a>])<br>                                               
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1976 Logic and                                                 
        Programming Languages (Dana S. Scott)<br>                                                
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1977 Can                                                 
        Programming Be Liberated from the von Neumann Style? (John Backus)<br>                                                
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1978 The Paradigm                                                 
        of Programming (Robert W. Floyd)<br>                                                
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1980 The                                                 
        Emperor's Old Clothes (Charles Anthony Richard Hoare)<br>                                                
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1983 Reflections                                                 
        on Trusting Trust (Ken Thompson)<br>                                                
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1984 From                                                 
        Programming Language Design to Computer Construction (Niklaus Wirth)<br>                                                
        &nbsp;&nbsp;&nbsp;&nbsp; Introduction to Part II Computers and Computing                                                 
        Methodologies (Richard L. Ashenhurst)<br>                                                
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1967 Computers                                                 
        Then and Now (Maurice V. Wilkes)<br>                                                
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1968 One Man's                                                 
        View of Computer Science (R. W. Hamming [<a href="#[Hamming1969]" target="_self">1969</a>])<br>                                               
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1969 Form and                                                 
        Content in Computer Science (Marvin Minsky)<br>                                                
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1970 Some                                                 
        Comments from a Numerical Analyst (J. H. Wilkinson)<br>                                                
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1971 Generality                                                 
        in Artificial Intelligence [Postscript] (John McCarthy)<br>                                                
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1973 The                                                 
        Programmer as Navigator (Charles W. Bachman)<br>                                                
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1975 Computer                                                 
        Science as Empirical Inquiry: Symbols and Search (Allen Newell and                                                 
        Herbert A. Simon)<br>                                                
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1976 Complexity                                                 
        of Computations (Michael O. Rabin)<br>                                                
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1979 Notation as                                                 
        a Tool of Thought (Kenneth E. Iverson)<br>                                                
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1981 Relational                                                 
        Database: A Practical Foundation for Productivity (E. F. Codd [<a href="#[Codd1982]">1982</a>])<br>                                               
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1982 An Overview                                                 
        of Computational Complexity (Stephen A. Cook)<br>                                                
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1985                                                 
        Combinatorics, Complexity, and Randomness (Richard M. Karp)<br>                                                
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                                 
        Piecing Together Complexity [Postscript] (Karen Frenkel)<br>                                                
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                                 
        Complexity and Parallel Processing: An Interview with Richard Karp                                                 
        [PostScript] (Karen Frenkel)<br>                                                
        &nbsp;&nbsp;&nbsp;&nbsp; Index According to ACM Computing Reviews                                                 
        Classification Scheme<br>                                                
        &nbsp;&nbsp;&nbsp;&nbsp; Name Index<br>                                                
        &nbsp;&nbsp;&nbsp;&nbsp; Subject Index<br>                                                
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</small></dd>            
      <dt>[<a name="Backus1959" href="#Backus1959">Backus1959</a>]</dt>
		<dd>Backus, J. W.&nbsp; The Syntax and Semantics of the Proposed 
		International Algebraic Language of the Zurich ACM-GAMM Conference.&nbsp;
		<i>Proceedings of the International Conference on Information Processing</i> 
		(UNESCO, 1959), 125-132.&nbsp; Available on the Internet (<a href="https://www.softwarepreservation.org/projects/ALGOL/paper/Backus-Syntax_and_Semantics_of_Proposed_IAL.pdf">typewritten 
		preprint</a>).<br>
&nbsp; The IAL became known as ALGOL 58 and the notation Backus introduced was 
		adapted by Peter Naur for the ALGOL 60 report.&nbsp; The notation became 
		known as BNF, now taken as short for &quot;Backus Naur Form.&quot;<br>
&nbsp;&nbsp; </dd>
		<dt>[<a name="Backus1978" href="#Backus1978">Backus1978</a>]</dt>
		<dd>Backus, John.&nbsp; Can programming be liberated from the von 
		Neumann style?&nbsp; a functional style and its algebra of programs.&nbsp;
		<i>Comm. ACM <b>21</b></i>, 8 (August 1978), 613-641.&nbsp; Turing Award 
		Lecture.&nbsp;&nbsp; Available on the Internet at
		&lt;<a href="htttps://doi.org/10.1145/359576.359579">doi:10.1145/359576.359579</a>&gt;.<br>
&nbsp;&nbsp;
&nbsp;&nbsp; </dd>
		<dt>[<a name="Baker1978" href="#Baker1978">Baker1978</a>]</dt>
		<dd>Baker, Henry G. List processing in real time on a serial computer.&nbsp;
		<i>Comm. ACM <b>21</b></i>, 4 (April 1978), 280-294.&nbsp; &lt;<a href="https://doi.org/10.1145/359460.359470">doi:10.1145/359460.359470</a>&gt;<br>
&nbsp;&nbsp; Abstract: &quot;A real-time list processing system is one in which the 
		time required by the elementary list operations (e.g. CONS, CAR, CDR, 
		RPLACA, RPLACD, EQ, and ATOM in LISP) is bounded by a (small) constant. 
		Classical implementations of list processing systems lack this property 
		because allocating a list cell from the heap may cause a garbage 
		collection, which process requires time proportional to the heap size to 
		finish. A real-time list processing system is presented which 
		continuously reclaims garbage, including directed cycles, while 
		linearizing and compacting the accessible cells into contiguous 
		locations to avoid fragmenting the free storage pool. The program is 
		small and requires no time-sharing interrupts, making it suitable for 
		microcode. Finally, the system requires the same average time, and not 
		more than twice the space, of a classical implementation, and those 
		space requirements can be reduced to approximately classical proportions 
		by compact list representation. Arrays of different sizes, a program 
		stack, and hash linking are simple extensions to our system, and 
		reference counting is found to be inferior for many applications.&quot;<br>
&nbsp;&nbsp; [dh:2025-11-22 This is the fundamental Baker algorithm I need to go 
		through more careful to grasp the specifics and see how this distills 
		down to a workable storage-management scheme for oMiser list structures.&nbsp; 
		I also think there is something more around generational 
		garbage-collection algorithms and I need to find it.&nbsp; I will need 
		to see if [Leiberman1983] improves on this and whether there is yet more 
		(apart from the insight to have heap-0 be on the runtime stack.]<br>
&nbsp;&nbsp; </dd>
		<dt>[<a name="Baker1990" href="#Baker1990">Baker1990</a>]</dt>
		<dd>Baker, Henry G. Efficient implementation of bit-vector operation in 
		Common Lisp.&nbsp; <i>ACM SIGPLAN Lisp Pointers <b>3</b></i>, 2-4 (April 
		1990), 8-22.&nbsp; &lt;<a href="https://doi.org/10.1145/121989.121991">doi:10.1145/121989.121991</a>&gt;.<br>
&nbsp;&nbsp; From the Abstract: &quot;In this paper we show various techniques for 
		the efficient implementation for the various functions of Common Lisp 
		involving bit-vectors and bit-arrays. ... [The] efficient manipulation 
		of bit-vectors in modern computers represents a curious point in the 
		spectrum of data processing tasks.&nbsp; On the one hand, the 
		possibility of packing many bits within a single computer word and 
		operating on all of them in parallel offers a potential for speedup not 
		usually available for other types of tasks. ... [The] efficient 
		implementation of bit-vector operations requires special-case code, and 
		is an interesting challenge in ingenuity and engineering.<br>
&nbsp;&nbsp; &quot;[We] show how word-wide parallelism can be utilized for almost all 
		of [the bit-vector operations in Common Lisp] to achieve speedups.&nbsp; 
		... The major exception will be Common Lisp&#39;s &#39;SEARCH&#39; function for 
		bit-vectors, which can also be speeded up [Baker1989].&quot;<br>
&nbsp;&nbsp; [dh:2025-11-22 This is rather intriguing when seen alongside 
		[Baker1990b].&nbsp; It would be remarkable if something like this could 
		somehow be introduced into Miser, though I am not confident about 
		oMiser.]<br>
&nbsp;&nbsp; </dd>
		<dt>[<a name="Baker1990b" href="#Baker1990b">Baker1990b</a>]</dt>
		<dd>Baker, Henry G. Unify and conquer. pp. 218-226 in <i>LFP&#39;90: 
		Proceeding of the 1990 ACM conference on LISP and functional programming</i>, 
		(Nice France: May 1990)&nbsp; &lt;<a href="https://doi.org/10.1145/91556.91652">doi:10.1145/91556.91652</a>&gt;.<br>
&nbsp;&nbsp; From the Abstract: <i>Type inference</i> is the process by which an 
		expression in an untyped computer language such as the lambda-calculus, 
		Lisp, or a functional language can be assigned a static data type in 
		order to improve the code generated by a compiler.&nbsp; <i>Storage use 
		inference</i> is the process by which a program ina computer language 
		can be statically analyzed to model its run-time behavior, particularly 
		the containment and sharing relations among its run-time data 
		structures.&nbsp; The information generated by storage use information 
		can also be used to improve the code generated by a compiler, because 
		knowledge of the containment and sharing relations of run-time data 
		structures allows for methods of storage allocation and deallocation 
		which are cheaper than garbage-collected heap storage and allows for the 
		in-place updating of functional aggregates. ... [The] best-known and 
		best-understood of the type inferencing algorithms--Milner&#39;s unification 
		method for ML--already generates valuable sharing and containment 
		information ... with no additional overhead during unification; however 
		there is some additional work necessary to extract this information. ... 
		[Our] scheme seems only to work for <i>functional languages </i>like 
		pure Lisp.<br>
&nbsp;&nbsp; [dh:2025-11-22 This is an intriguing situation.&nbsp; It might not 
		be workable with regard to type inference from pure functional types, 
		such as that provided by combinators, and it might require distinguished 
		(base) types already.&nbsp; I take this as something fruitful to 
		explore.]<br>
&nbsp;&nbsp; </dd>
		<dt>[<a name="Baker1991" href="#Baker1991">Baker1991</a>]</dt>
		<dd>Baker, Henry G. Shallow binding makes functional arrays fast.&nbsp;
		<i>ACM SIGPLAN Notices <b>26</b></i>, 8 (August 1991), 145-147.&nbsp; &lt;<a href="https://doi.org/10.1145/122598.122614">doi:10.1145/122598.122614</a>&gt;<br>
		<font size="2">&nbsp;&nbsp; From the Abstract: Access and update for 
		random elements of arrays in imperative programming languages are O(1) 
		operation.&nbsp; Implementing functional programming languages to 
		achieve equivalent efficiency has proved difficult.&nbsp; We show how 
		the straight-forward application of shallow binding to functional arrays 
		automatically achieves O(1) update for single-threaded usage.<br>
&nbsp;&nbsp; [dh:2025-11-22 This is a general problem with respect to the 
		absence of assignment operations leading to concern for alterations of 
		aggregates involves transformation to a derived aggregate regardless of 
		how miniscule an individual change might be.&nbsp; This applies to any 
		kind of aggregated structure, not just arrays.&nbsp; This article does 
		not illustrate shallow binding and other resources must be consulted.]<br>
&nbsp;</font></dd>
		<dt>[<a name="Baker1992" href="#Baker1992">Baker1992</a>]</dt>
		<dd>Baker, Henry G. CONS should not CONS its arguments, or, a lazy alloc 
		is a smart alloc.&nbsp; <i>ACM SIGPLAN Notices <b>27</b></i>, 3 (March 
		1992), 24-34.&nbsp; &lt;<a href="https://doi.org/10.1145/130854.130858">doi:10.1145/130854.130858</a>&gt;<br>
		<font size="2">&nbsp; From the Abstract: <i>Lazy allocation</i> is a 
		model for allocating objects on the execution stack of a high-level 
		language which does not create dangling references.&nbsp; Our model 
		provides safe transportation into the heap for objects tha may survive 
		the deallocation of the surrounding stack frame.&nbsp; Space for objects 
		that do not survive the deallocation of the surrounding stack frame is 
		reclaimed without additional effort when the stack is popped<br>
&nbsp;&nbsp; [dh:2025-11-22 This is precisely the technique that I am interested 
		in for the Miser Project.&nbsp; [Baker1995] may provide a core aspect of 
		the technique, and this 1992 article may address additional questions 
		about ensuring no references from outside the retreated stack frame are 
		left dangling.]<br>
&nbsp;&nbsp; </font></dd>
		<dt>[<a name="Baker1992d" href="#Baker1992d">Baker1992d</a>]</dt>
		<dd>Baker, Henry G. Less complex elementary functions.&nbsp; <i>ACM 
		SIGPLAN Notices <b>27</b></i>, 11 (November 1992), 15-16.<br>
		<font size="2">&nbsp;&nbsp; From the Abstract:&nbsp; &quot;We give formulae 
		for complex elementary functions in which the real and imaginary parts 
		can be computed separately using only real operations.&nbsp; Many of 
		thesse formulae are obvious but some--e.g., asin(z), ..., atanh(z)--are 
		not obvious and/or not well-known.<br>
		</font>&nbsp;</dd>
		<dt>[<a name="Baker1993b" href="#Baker1993b">Baker1993b</a>]</dt>
		<dd>Baker, Henry G.&nbsp; The Boyer benchmark meets linear logic.&nbsp;
		<i>ACM SIGPLAN Lisp Pointers, <b>6</b></i>, 4 (October 1993), 3-10.&nbsp; 
		Available on the Internet at &lt;<a href="https://doi.org/10.1145/181889.181890">doi:10.1145/181889.181890</a>&gt;.<br>
		<font size="2">&nbsp;&nbsp; From the abstract: &quot;Of the Gabriel Lisp 
		Benchmarks, the Boyer Benchmark (&quot;Boyer&quot;) is the most representative of 
		real AI applications, because it performs .. rule-directed rewriting and 
		because it relies heavily on garbage collection (GC) for the recovery of 
		storage.&nbsp; We investigated the notion that such programs are 
		unsuitable for explicit storage management.&quot;<br>
&nbsp;&nbsp; The Boyer benchmark has several bugs that are corrected in this 
		paper.&nbsp; The paper ends with &quot;A short Tutorial on &#39;Linear&#39; Lisp.&quot;&nbsp; 
		[dh:2025-11-22 This appears to be making procedures tail-recursive and 
		I&#39;m uncertain about the necessity of the linear logic approach that 
		involves explicit &quot;killing&quot; of variables.&nbsp; It seems easier to 
		specify as a tail-recursive form to start with.&nbsp; There does seem to 
		be an opportunity to effectively de-reference the original argument by 
		essentially reusing the &quot;frame.&quot;&nbsp; This needs exploration.]&nbsp;
		<br>
&nbsp;&nbsp; [dh:2025-11-22 This is as much about Functional Programming as a 
		general Computer Science Topic.&nbsp; It is about the nuts-and-bolts 
		under the covers of functional-style operations and there being 
		bench-mark stress tests is of particular interest.&nbsp; The [<a href="#Gabriel1985">Gabriel1985: 
		Boyer Benchmark</a>] is useful as a stress test for Functional 
		Programming approaches, including that of the Miser Project, but 
		transposition into an oFrugal script may be challenging.]<br>
		</font>&nbsp;&nbsp; </dd>
		<dt>[<a name="Baker1994" href="#Baker1994">Baker1994</a>]</dt>
		<dd>Baker, Henry G. Thermodynamics and garbage collection.&nbsp; <i>ACM 
		SIGPLAN Notices <b>29</b></i>, 4 (April 1, 1994), 58-63.&nbsp; Available 
		on the Internet at&nbsp; &lt;<a property="sameAs" style="box-sizing: border-box; background-color: rgb(255, 255, 255); cursor: pointer; color: inherit; text-decoration: underline; transition: background 0.15s ease-in-out, color 0.15s ease-in-out; line-height: 1; font-family: &quot;Open Sans&quot;, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 300; letter-spacing: normal; orphans: 2; text-align: start; text-indent: -20px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal;" href="https://doi.org/10.1145/181761.181770">doi:10.1145/181761.181770</a>&gt;.<br>
		<font size="2">&nbsp;&nbsp; Abstract: &quot;We discuss the principles of 
		statistical thermodynamics and their application to storage management 
		problems.&nbsp; We point out problems which result from imprecise usage 
		of the terms<i> information, state, reversible, conservative</i>, etc.&quot;<br>
&nbsp;&nbsp; </font></dd>
		<dt>[<a name="Baker1994b" href="#Baker1994b">Baker1994b</a>]</dt>
		<dd>Baker, Henry G. Minimizing reference count updating with deferred 
		and anchored pointers for functional data structures.&nbsp; <i>ACM 
		SIGPLAN Notices <b>29</b></i>, 9 (September 1, 1994), 38-43.&nbsp; 
		Available on the Internet at &lt;<a property="sameAs" style="box-sizing: border-box; background-color: rgb(255, 255, 255); cursor: pointer; color: inherit; text-decoration: underline; transition: background 0.15s ease-in-out, color 0.15s ease-in-out; line-height: 1; font-family: &quot;Open Sans&quot;, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 300; letter-spacing: normal; orphans: 2; text-align: start; text-indent: -20px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal;" href="https://doi.org/10.1145/185009.185016">doi:10.1145/185009.185016</a>&gt;.<br>
		<font size="2">&nbsp;&nbsp; From the abstract: &quot;Reference counting can 
		be an attractive form of dynamic storage management.&nbsp; It recovers 
		storage promptly and (with a garbage stack instead of a free list) it 
		can be made &quot;real-time&quot;--i.e., all accesses can be performed in constant 
		time.&nbsp; Its major drawbacks are its inability to reclaim cycles, its 
		count storage, and its count update overhead.&nbsp; Update overhead is 
		especially irritating for functional (read-only) date ... .&nbsp; We 
		show how reference count updating can be largely eliminated for 
		functional data structures ... .&quot;</font><br>
&nbsp;&nbsp; </dd>
		<dt>[<a name="Baker1995" href="#Baker1995">Baker1995</a>]</dt>
		<dd>Baker, Henry G.&nbsp; CONS should not CONS its arguments, part II: 
		Cheney on the M.T.A.&nbsp; <i>ACM SIGPLAN Notices <b>30</b></i>, 9 
		(September 1, 1995), 17-20. Available on the Internet at &lt;<a property="sameAs" style="box-sizing: border-box; background-color: rgb(255, 255, 255); cursor: pointer; color: inherit; text-decoration: underline; transition: background 0.15s ease-in-out, color 0.15s ease-in-out; line-height: 1; font-family: &quot;Open Sans&quot;, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 300; letter-spacing: normal; orphans: 2; text-align: start; text-indent: -20px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal;" href="https://doi.org/10.1145/214448.214454">doi:10.1145/214448.214454</a>&gt;.<br>
&nbsp;&nbsp; Part I is [<a href="#Baker1992">Baker1992</a>]<br>
&nbsp;&nbsp; </dd>
		<dt>[<a name="Biermann1997" href="#Biermann1997">Biermann1997</a>]</dt>
      <dd>Biermann, Alan W.&nbsp; <i>Great Ideas in Computer Science: A Gentle                                    
        Introduction</i>.&nbsp; ed.2.&nbsp; MIT Press (Cambridge, MA: 1990,                                    
        1997).&nbsp; ISBN 0-262-52223-3 pbk. alk. paper<small><br>                                 
        &nbsp;&nbsp;&nbsp;&nbsp; &quot;This is a book about computers--what they                                
        are, how they work, what they can do, and what they cannot do.&nbsp; It                                
        is written for people who read about such topics as computers networks                                
        or artificial intelligence and want to understand them, for people who                                
        need to have data processed on the job and want to know what can and                                
        cannot be done, and for people who see the proliferation of computers                                
        throughout society and ask about the meaning of it all.&nbsp; It is                                
        written for doctors, lawyers, preachers, teachers, managers, students,                                
        and all others who have a curiosity to learn about computing.&nbsp; It                                
        is also written for computer science students and professionals whose                                
        education may not have covered all the important areas, and who want to                                
        broaden themselves.&quot; -- from the Preface, p.<i>xv</i>.<br>                               
        &nbsp;&nbsp;&nbsp;&nbsp; &quot;This book was written on the assumption                                
        that intelligent people can understand every fundamental issue of                                
        computer science if the preparation and explanation are adequate. ...<br>                               
        &nbsp;&nbsp;&nbsp;&nbsp; &quot;Because casual readers may not wish to                                
        read all the chapters, the book is designed to encourage dabbling.&nbsp;                                
        Readers are encouraged to jump to any chapter at any time and read as                                
        much as is of interest. ...<br>                               
        &nbsp;&nbsp;&nbsp;&nbsp; &quot;... Chapter sections labeled A include                                
        only introductory material and make few demands on the reader.&nbsp; One can get an overview of the book in a single evening by reading                                
        them.&nbsp; The B sections are the primary material of the book and may                                
        require substantial time and effort, but the reader who completes them                                
        will have a deep understanding of the major lessons on that topic.&nbsp;                                
        The C material answers questions that careful readers may ask and                                
        supplements the main portions of the book.&quot;&nbsp; -- from the                                
        Introduction, p.<i>xxiv</i>.<br>                               
        &nbsp;&nbsp;&nbsp;&nbsp; I just became aware of this book out of recent                                
        discussions of my experience seeing how programming languages are taught                                
        and on how the principles of computing (as opposed to the technology <i>du                                
        jour</i>) are introduced.&nbsp; I am very much in favor of this approach                                
        and the proposal that computing be made accessible to anyone to the                                
        degree that they choose to explore it.&nbsp; I strongly favor any                                
        approach that promotes readers and students distilling out the ideas                                
        behind the practices and concrete examples.<br>                               
        &nbsp;&nbsp;&nbsp;&nbsp; This book offers a practical approach that                              
        encourages the reader to sit down at a computer and explore and confirm what                                
        is presented.&nbsp; The book is not a programming text -- programs and                                
        programming are introduced as vehicles of demonstration.&nbsp; I am                                
        keenly interested in this hands-on approach and in how that can be used                                
        to illustrate principles without having the principle associated too                                
        tightly (or even be confused with) the technology that is applied as the                                
        instrument of illustration.<br>                              
        &nbsp;&nbsp;&nbsp;&nbsp; A subset of Pascal is used, in the spirit of [<a href="#Sedgewick1989">Sedgewick1989</a>],                                
        and the examples are developed in Turbo Pascal.&nbsp; There is a single                                
        page devoted to what is needed and how to get started, including the                                
        following wonderful paragraph: &quot;The [computer system] manual is                                
        necessary because it will tell you which buttons to push on your                                
        computer to turn it on and to get your program typed in and                                
        running.&nbsp; Finally, you need an instructor or friend to tell you                                
        what the manual did not.&nbsp; Computer Science, like many disciplines,                                
        has an oral tradition, and some of the most important facts are passed                                
        only by word of mouth.&nbsp; You may be able to get along without this                                
        help, but learning is usually easier if it is there (p.11).&quot;<br>                               
        &nbsp;&nbsp;&nbsp;&nbsp; The recognition of the amount of tacit                                
        knowledge that is assumed in even the most elementary treatment of                                
        computing, as far as hands-on treatment goes, is very welcome.&nbsp; My                                
        experience is that more is called for here, though I can accept the                                
        author not choosing to take on that task as part of his project.&nbsp;                                
        Now that Pascal has gone out of favor and economical implementations are                                
        no longer commonplace, it will take more work to apply the examples.&nbsp; This has me wondering whether there is an advantage to                                
        two levels of exposition -- something like design plus representative                                
        implementation -- if there is going to be provision for hands-on                                
        confirmation, demonstration, and exploration that can endure technology                                
        fashions while also accentuating <i>how</i> the ideas are manifest in the concrete                                
        examples. -- dh:2003-07-31</small></dd>                               
      <dd><small> 
        &nbsp;&nbsp; Content<br>                                 
        <i>&nbsp;&nbsp;&nbsp;&nbsp; Preface to the Second Edition<br>
        &nbsp;&nbsp;&nbsp;&nbsp; Preface<br>
        &nbsp;&nbsp;&nbsp;&nbsp; Studying Academic Computer Science: An 
        Introduction</i><br>
        &nbsp;&nbsp;&nbsp;&nbsp; 1. An Introduction to Programming: Coding                                 
        Decision Trees<br>                                
        &nbsp;&nbsp;&nbsp;&nbsp; 2. Text Manipulation and Algorithm Design<br>                                
        &nbsp;&nbsp;&nbsp;&nbsp; 3. Numerical Computation and a Study of                                 
        Functions<br>
        &nbsp;&nbsp;&nbsp;&nbsp; 4. Top-Down Programming, Subroutines, and a                                 
        Database Application<br>                                
        &nbsp;&nbsp;&nbsp;&nbsp; 5. Simulation<br>                                
        &nbsp;&nbsp;&nbsp;&nbsp; 6. Software Engineering<br>                                
        &nbsp;&nbsp;&nbsp;&nbsp; 7. Electric Circuits<br>                                
        &nbsp;&nbsp;&nbsp;&nbsp; 8. Machine Architecture<br>                                
        &nbsp;&nbsp;&nbsp;&nbsp; 9. Language Translation<br>                                
        &nbsp;&nbsp;&nbsp;&nbsp; 10. Virtual Environments for Computing<br>                                
        &nbsp;&nbsp;&nbsp;&nbsp; 11. Computer Communications<br>                                
        &nbsp;&nbsp;&nbsp;&nbsp; 12. Program Execution Time<br>                                
        &nbsp;&nbsp;&nbsp;&nbsp; 13. Parallel Computation<br>                                
        &nbsp;&nbsp;&nbsp;&nbsp; 14. Noncomputability<br>                                
        &nbsp;&nbsp;&nbsp;&nbsp; 15. Artificial Intelligence<br>                                
        &nbsp;&nbsp;&nbsp;&nbsp; Appendix A.&nbsp; The Rules for the Subset of                                 
        Pascal Used in this Book<br>                                
        &nbsp;&nbsp;&nbsp;&nbsp; Appendix B.&nbsp; Two Simulation Programs<br>                                
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Readings<br>                               
        &nbsp;&nbsp;&nbsp;&nbsp; Index</i><br>  
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</small></dd>
      <dt>[<a name="Biermann2002" href="#Biermann2002">Biermann2002</a>]</dt>
      <dd><a href="http://www.cs.duke.edu/~awb/" target="_top">Biermann, Alan W</a>., Ramm, Dietolf.&nbsp;                               
        <a href="http://www.cs.duke.edu/~dept/Great_Ideas_with_Java/index.html" target="_top"><i>Great Ideas in Computer  
        Science with Java</i></a>.&nbsp; MIT Press (Cambridge, MA: 2002).&nbsp; ISBN                                
        0-262-02497-7 pbk. alk. paper.<small><br>                               
        &nbsp;&nbsp;&nbsp;&nbsp; There is an errata at <a href="http://www.cs.duke.edu/~dept/Great_Ideas_with_Java/errata.html" target="_top">http://www.cs.duke.edu/~dept/Great_Ideas_with_Java/errata.html</a>.<br>    
        </small><small>&nbsp;&nbsp;&nbsp;&nbsp; &quot;This book is written for     
        people who find themselves on the outside of a high-technology world and     
        who want to find a way in. ...<br>    
        </small><small>&nbsp;&nbsp;&nbsp;&nbsp; &quot;This book presents the     
        story of computer science organized around the theme of the 'great     
        ideas' of the field.&nbsp; These are the discoveries, the paradigms, the     
        simplifying equations that attract the attention of everyone who comes     
        near, and they provide the best-known paths to understanding. ...<br>    
        </small><small>&nbsp;&nbsp;&nbsp;&nbsp; &quot;The method of teaching is     
        by doing rather than just by reading and talking.&nbsp; The theory is     
        that if you personally go through the steps of creating a program to do     
        something or if you hand-simulate a process, that mechanism and the     
        related ideas will get built into your body as well as your mind.&nbsp;     
        They will become instinctive as well as intellectually known. ... This     
        is the problems-oriented approach to teaching that has been so     
        successful in the traditional quantitative sciences.&quot; -- from the     
        Preface, pp. <i>xiii-xiv</i>.<br>    
        &nbsp;&nbsp;&nbsp;&nbsp; A number of alterations have appeared since the     
        previous version [<a href="#[Biermann1997]">Biermann1997</a>].&nbsp;     
        First, scholarly publishing is losing its memory -- there is no     
        recognition of prior editions in the history of the book and certainly     
        not in the copyright notice -- a recent practice about which I have my     
        suspicions and my doubts.</small><small>&nbsp; And the Preface     
        completely disregards the possibility that we have been here before.<br>    
        </small><small>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Secondly, the language of     
        choice for illustration of computer science is now Java.&nbsp; With     
        regard to availability, support, and high interest, that is difficult to     
        fault.&nbsp; It is also an avenue to the currently-favored approach for     
        GUI and graphics work as well as a way of exploring an object-oriented     
        technology (OOT).<br>    
        </small><small>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The &quot;gentle     
        introduction&quot; isn't quite so gentle, and the immediate support for     
        hands-on experience does not come across so well nor so early as in the     
        previous chapters 1-2.&nbsp; It seems that this book is seriously     
        intended as a textbook with a companion laboratory or instructional     
        support for the nitty-gritty, working-at-a-keyboard parts.&nbsp; I miss     
        the promise of an introduction for anyone with the interest and    
        curiosity.&nbsp;&nbsp;<br>
        </small><small>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; There is something less    
        situated about the introduction of Java and starting with applets so    
        unceremoniously.&nbsp; I am also concerned with having to deal with OOT    
        so early just because there is no other way to accomplish anything    
        useful in Java.&nbsp; Here the neophyte may never know, in a clear way,    
        whether we are doing OOP or simply using the OOT to accomplish some    
        straightforward OOP-indifferent task by idiomatic application of the    
        object-oriented technology (e.g., as with main(), or java.lang.Math, or    
        init()-as-main()).&nbsp; And identifying what we are actually doing when    
        we extend a GUI-component class, and how that ties to OOP, takes some    
        masterful explication (not included here -- where </small><code><b>interface</b>    
        ActionListener</code><small> implementation begins on p.86 and 
        is nowhere addressed that I can find.) That it cost the readers of this 
        book an introduction to text processing and algorithm design</small><small> 
        is unfortunate.<br>   
        &nbsp;&nbsp;&nbsp;&nbsp; Having said all of that, I strongly favor a    
        hands-on, experience-it and demonstrate-it-yourself approach.&nbsp;    
        There is much value here.&nbsp; And, I think, there's more to accomplish in    
        execution on the promise to demonstrate the great ideas in a way that    
        brings them to life for people.</small><small>&nbsp; It would be useful    
        to not have the tool be in the way.</small><small> --dh:2003-07-31<br>  
        &nbsp;&nbsp;&nbsp;&nbsp; <font size="-1">An updated, extended version of  
        this pr√©cis appears <a href="http://www.amazon.com/exec/obidos/ASIN/0262024977/" target="_top">on 
        amazon.com</a>. --dh:2003-10-17</font><br> 
        &nbsp;&nbsp; Content.<br>  
        &nbsp;&nbsp;&nbsp;&nbsp; Preface<br>  
        &nbsp;&nbsp;&nbsp;&nbsp; Studying Academic Computer Science: An   
        Introduction<br>
        &nbsp;&nbsp;&nbsp;&nbsp; 1. The World Wide Web<br>  
        </small>&nbsp;&nbsp;&nbsp;<small> 2. Watch Out: Here Comes Java<br>                              
        &nbsp;&nbsp;&nbsp;&nbsp; 3. Numerical Computation and a Study of                               
        Functions<br>
        &nbsp;&nbsp;&nbsp;&nbsp; 4. Top-Down Programming, Subroutines and a                               
        Database Application<br>                              
        &nbsp;&nbsp;&nbsp;&nbsp; 5. Graphics, Classes, and Objects<br>                              
        &nbsp;&nbsp;&nbsp;&nbsp; 6. Simulation<br>                              
        &nbsp;&nbsp;&nbsp;&nbsp; 7. Software Engineering<br>                              
        &nbsp;&nbsp;&nbsp;&nbsp; 8. Machine Architecture<br>                              
        &nbsp;&nbsp;&nbsp;&nbsp; 9. Language Translation<br>                              
        &nbsp;&nbsp;&nbsp;&nbsp; 10. Virtual Environments for Computing<br>                              
        &nbsp;&nbsp;&nbsp;&nbsp; 11. Security, Privacy, and Wishful Thinking<br>                              
        &nbsp;&nbsp;&nbsp;&nbsp; 12. Computer Communication<br>                              
        &nbsp;&nbsp;&nbsp;&nbsp; 13. Program Execution Time<br>                              
        &nbsp;&nbsp;&nbsp;&nbsp; 14. Parallel Computation<br>                              
        &nbsp;&nbsp;&nbsp;&nbsp; 15. Noncomputability<br>                              
        &nbsp;&nbsp;&nbsp;&nbsp; 16. Artificial Intelligence<br>                              
        &nbsp;&nbsp;&nbsp;&nbsp; Appendix: The IntField and DoubleField Classes<br>                              
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Readings<br>                              
        &nbsp;&nbsp;&nbsp;&nbsp; Index<br>                              
        &nbsp;&nbsp;&nbsp;</i></small></dd>
      <dt>[<a name="Bird1997" href="#Bird1997">Bird1997</a>]</dt>                 
      <dd>Bird, Richard., de Moor, Oege.&nbsp; <i>Algebra of Programming</i>.&nbsp;                                                       
        Prentice-Hall (Harlow, England: 1997).&nbsp; ISBN 0-13-507245-X.<font size="-1"><br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp; &quot;[This book] codifies the basic laws of                                                       
        algorithmics, and shows how they can be used to classify many ingenious                                                       
        and important programs into families related by the algebraic properties                                                       
        of their specifications.&nbsp; The formulae and equations that you will                                                       
        see here share the elegance of those which underlie physics or chemistry                                                       
        or any other branch of basic science; and like them, they inspire our                                                       
        interest, enlarge our understanding, and hold out promise of enduring                                                       
        benefits in application.&quot;&nbsp; From the Foreword by Tony Hoare, p.                                                       
        <i>ix</i>.<br>                   
        &nbsp;&nbsp; Content<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Foreword<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp; Preface</i><br>                   
        &nbsp;&nbsp;&nbsp;&nbsp; 1. Programs<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp; 2. Functions and Categories<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp; 3. Applications<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp; 4. Relations and Allegories<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp; 5. Datatypes in Allegories<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp; 6. Recursive Programs<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp; 7. Optimisation Problems<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp; 8. Thinning Algorithms<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp; 9. Dynamic Programming<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp; 10. Greedy Algorithms<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Appendix<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp; Bibliography<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp; Index<br>                                                       
        &nbsp;&nbsp;&nbsp;</i></font></dd>
		<dt>[<a name="Bratman1961" href="#Bratman1961">Bratman1961</a>]</dt>
		<dd>Bratman, H.&nbsp; An alternate form of the &quot;UNCOL diagram.&quot;&nbsp; <i>
		Comm. ACM <b>4</b></i>, 3 (March 1961), 142.<br>
		<font size="2">&nbsp;&nbsp; The basic idea was to illustrate, in a 
		building-block manner, how a compiler could be used to produce programs, 
		including compilers for the same or different language.<br>
		The specific Universal Common Language (UNCOL) case was an early idea to 
		have common back-ends that would compile from an intermediate language 
		and achieve portable implementations of programming languages by 
		compiling to the UNCOL intermediate.&nbsp; And I have probably 
		over-simplified the whole thing.&nbsp; Oddly, the use of a common often 
		interpretive run-time has satisfied this requirement in the case of Java 
		and especially .NET.&nbsp; I do use the diagramming technique though.<br>
&nbsp;&nbsp; At the Turing Centenary celebration in San Francisco, I approached 
		Charles Bachman and thanked him for his great diagramming technique.&nbsp; 
		He didn&#39;t know what I was talking about, of course.&nbsp; I had 
		misremembered the name of this source.<br>
		</font>&nbsp;&nbsp; </dd>
      <dt>[<a name="Brookshear2003" href="#Brookshear2003">Brookshear2003</a>]</dt>                   
      <dd><a href="http://mscs.mu.edu/~glennb/" target="_top">Brookshear,                   
        J.Glenn</a>.&nbsp; <i>Computer Science: An Overview</i>.&nbsp;                                                       
        ed.7.&nbsp; <a href="http://www.aw.com" target="_top">Addison-Wesley</a>                                                       
        (Boston: 2003).&nbsp; ISBN 0-201-78130-1 pbk.<small><br>                                                      
        &nbsp;&nbsp;&nbsp;&nbsp; 2002-11-18: This book is designed and promoted                                                       
        as a textbook for module CS0, Introduction to Computer Science</small><small>.&nbsp;                                                       
        The traditional designation (introduced in Computer Science Curriculum                                                       
        78) of courses CS1, CS2, ... commences with programming.&nbsp; In                                                       
        breadth-first approaches, there is an overview of computer science                                                       
        topics that precedes the first collegiate programming                                                       
        course.&nbsp;&nbsp; The overview can be designed for non-majors as                                                       
        well.&nbsp; This is apparently CS0, or, in the terminology for Computing                                                       
        Curriculum 2001, CS100<span style="font-variant: small-caps">b</span>.&nbsp;                                                       
        Providing this breadth-first overview for non-majors and majors alike is                                                       
        the express purpose of this book.<br>                                                      
        &nbsp;&nbsp;&nbsp;&nbsp; &quot;I wrote this text for both computer                                                       
        science majors and students from other disciplines.&nbsp; As for                                                       
        computer science majors, most begin their studies with the illusion that                                                       
        computer science is programming and Web browsing since that is                                                       
        essentially all they have seen.&nbsp; Yet computer science is much more                                                       
        than this.&quot; -- From the preface, p.<i>v</i>.<br>                                                      
        &nbsp;&nbsp;&nbsp;&nbsp; 2002-11-02, -11-28: When I <a href="../blog/archive/2002_10_27_lair-chive.asp#83887114" target="_self">first                                                       
        learned</a> that this book is used for the mandatory Computer Structures                                                     
        course of the University of Liverpool M.Sc in Information Technology                                                       
        on-line degree, I checked it out on <a href="http://www.amazon.com/exec/obidos/ASIN/0201781301/" target="_top">amazon.com</a>.&nbsp;                                                       
        I was a little surprised at the cross-section of the reader                                                       
        reviews.&nbsp; There were those -- apparently practitioners -- who                                                       
        disliked the book for the absence of programming and software                                                       
        approaches.&nbsp; Many of these dismissed it as too elementary.&nbsp;                                                       
        There was a second group who found it valuable in preparation for                                                       
        examinations in introductory computer science.&nbsp; And then there were                                                       
        those who raved about the book because it gave them grounding and                                                       
        insights that they had been seeking.&nbsp; It would seem that some did                                                       
        not check to see what the author's intention is.&nbsp; I expect to be                                                       
        satisfied.&nbsp; One odd thing though.&nbsp; As soon as I ordered the                                                       
        book, amazon.com began recommending other books of an elementary nature that                                                       
        are considered good study guides for various introductory-subject examinations.&nbsp;                                                    
        Their recommendations have lately returned to something more like my                                                     
        typical interests, however.<br>                                                     
        &nbsp;&nbsp;&nbsp;&nbsp; The <a href="http://mscs.mu.edu/~glennb/" target="_top">author's                                                       
        web site</a> provides an <a href="http://http://mscs.mu.edu/~glennb/errata7.html" target="_top">errata                                                       
        for this edition</a>.<br>                   
        &nbsp;&nbsp;&nbsp;&nbsp; The publisher has a <a href="http://www.aw.com/brookshear/" target="_top">web                                                       
        site for the book</a>, with links, PowerPoint slides, and supplementary                                                       
        materials.</small></dd>                  
      <dd><small>&nbsp;&nbsp; Content<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Preface</i><br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0. Introduction<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Part One: Machine Architecture</i><br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1. Data Storage<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2. Data                                                       
        Manipulation<br>                   
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Part Two: Software</i><br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3. Operating                                                       
        Systems and Networks<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4. Algorithms<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5. Programming                                                       
        Languages<br>                   
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6. Software                                                       
        Engineering<br>                   
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Part Three: Data Organization</i><br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7. Data                                                       
        Structures<br>                   
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8. File                                                       
        Structures<br>                   
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 9. Database                                                       
        Structures<br>                   
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Part Four: The Potential of Machines</i><br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10. Artificial                                                       
        Intelligence<br>                   
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 11. Theory of                                                       
        Computation<br>                   
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Appendixes</i><br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A. ASCII<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B. Circuits to                                                       
        Manipulate Two's Complement Representations<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C. A Simple                                                       
        Machine Language<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D. High-Level                                                       
        Language Program Examples<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; E. The                                                       
        Equivalence of Iterative and Recursive Structures<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; F. Answers to                                                       
        Questions/Exercises<br>                   
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Index</i><br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</small></dd>                   
      <dt>[<a name="Cheatham1964" href="#Cheatham1964">Cheatham1964</a>]</dt>
		<dd>Cheathan, T. E. Jr., Sattley, Kirk.&nbsp; Syntax-Directed Compiling.&nbsp; 
		Proceedings of the April 21-23 1964 Spring Joint Computer Conference (AFIPS: 
		April 1964), 31-57.<br>
&nbsp;A general parser (syntax analyzer) for context-free languages is 
		described. What we now refer to as a lexical analyser is identified as a 
		recognizer layer. The analyzer method is most easily recognized as a 
		top-down parser with back-tracking. It could even be used to produce all 
		analyses available for an ambiguous input. Refinements of this method 
		that I have explored include pruning alternatives when they cannot be 
		possible if the input will be valid. This allows early analysis to be 
		forwarded to a generation layer. There also needs to be some assistance 
		in the case of left-recursive generations, usually expedited by 
		transformation into tail-iterative forms. <br>
&nbsp;&nbsp; </dd>
		<dt>[<a name="Clinger1990" href="#Clinger1990">Clinger1990</a>]</dt>
		<dd>Clinger, William D.&nbsp; How to read floating point numbers 
		accurately.&nbsp; <i>PLDI &#39;90: Proceedings of the ACM SIGPLAN 1990 
		Conference on Programming Language Design and Implementation</i>.&nbsp; 
		June 1990, pp.92-101. &lt;<a href="https://doi.org/10.1145/93542.93557">doi:10.1145/93542.93557</a>&gt;<br>
&nbsp;&nbsp; From the abstract: &quot;The input problem considered by this paper is 
		the inverse of an output problem considered by [<a href="#Steele1990">Steele1990</a>].&quot;&nbsp; 
		&quot;This paper present an efficient algorithm that always finds the best 
		approximation.&quot;<br>
&nbsp;&nbsp; </dd>
		<dt>[<a name="Codd1970" href="#Codd1970">Codd1970</a>]</dt>
      <dd>Codd, E.F.&nbsp; <a href="http://doi.acm.org/10.1145/362384.362685" target="_top">A                            
        Relational Model of Data for Large Shared Data Banks</a>.&nbsp; <i>Comm.                            
        ACM <b>13</b></i>, 6 (<a href="http://portal.acm.org/citation.cfm?id=362384" target="_top">June                            
        1970</a>), 377-387.&nbsp; Available on the web as an <a href="http://www.acm.org/classics/nov95/" target="_top">ACM                            
        Classic</a> (<a href="http://nfocentrale.net/orcmid/blog/2003_09_07_lair-chive.asp#106298271295998044" target="_top">without                            
        Section 2</a>).&nbsp; A <a href="http://www.scism.sbu.ac.uk/~rmkemp/codd1970.pdf" target="_top">PDF</a>                            
        of the complete paper is available <a target="_top" href="http://www.scism.sbu.ac.uk/~rmkemp/">here</a>.<br>                           
        &nbsp;&nbsp;&nbsp;</dd>
      <dt>[<a name="Codd1971" href="#Codd1971">Codd1971</a>]</dt>
      <dd>Codd, E.F.&nbsp; Normalized Data Base Structure: A Brief                            
        Tutorial.&nbsp; Proc. 1971 ACM SIGFIDET Workshop on Data Description,                            
        Access, and Control.&nbsp; San Diego, California, November 11-12, 1971.<br>                           
        &nbsp;&nbsp;&nbsp;</dd>
      <dt>[<a name="Codd1972a" href="#Codd1972a">Codd1972a</a>]</dt>
      <dd>Codd, E.F.&nbsp; Further Normalization of the Data Base Relational                            
        Model.&nbsp; in Rustin, Randall J.(ed.).&nbsp; <i>Data Base Systems</i>.&nbsp;&nbsp;                            
        Courant Computer Symposia Series, vol. 6.&nbsp; Prentice-Hall (Englewood                            
        Cliffs, NJ: 1972).<small><br>                           
        &nbsp;&nbsp;&nbsp;&nbsp; This is is where the second and third normal                           
        forms were introduced.&nbsp; Ron Fagin introduced the fourth and fifth                           
        normal forms.&nbsp; Chris Date has introduced a sixth, but it is clear                           
        that the the fifth is complete.&nbsp;&nbsp;<br>                          
        &nbsp;&nbsp;&nbsp;</small></dd>
      <dt>[<a name="Codd1972b" href="#Codd1972b">Codd1972b</a>]</dt>
      <dd>Codd, E.F.&nbsp; Relational Completeness of Data Base Sublanguages in                            
        Data Base Systems.&nbsp; pp. 65-98 in Rustin, Randall J.(ed.).&nbsp; <i>Data                            
        Base Systems</i>.&nbsp;&nbsp; Courant Computer Symposia Series, vol.                            
        6.&nbsp; Prentice-Hall (Englewood Cliffs, NJ: 1972).<br>                           
        &nbsp;&nbsp;&nbsp;</dd>
      <dt>[<a name="Codd1974" href="#Codd1974">Codd1974</a>]</dt>
      <dd>Codd, E.F.&nbsp; Interactive Support for Nonprogrammers:&nbsp; The                            
        Relational and Network Approach.&nbsp; in Proc. ACM SIGMOD Workshop on                            
        Data Description, Access and Control, vol. II.&nbsp; Ann Arbor,                            
        Michigan, May, 1974.<br>                           
        &nbsp;&nbsp;&nbsp;</dd>
      <dt>[<a name="Codd1979" href="#Codd1979">Codd1979</a>]</dt>
      <dd>Codd, E.F.&nbsp; <a href="http:/doi.acm.org/10.1145/320107.320109" target="_top">Extending the Data Base Relational Model to Capture                            
        More Meaning</a>.&nbsp; <i>ACM Trans. on Database Systems <b>4</b></i>, 4                            
        (December 1979), 397-434.&nbsp; A <a href="http://www.scism.sbu.ac.uk/~rmkemp/codd1979.pdf" target="_top">PDF</a>                        
        is available <a href="http://www.scism.sbu.ac.uk/~rmkemp/" target="_top">here</a>.<br>                          
        &nbsp;&nbsp;&nbsp;</dd>
      <dt>[<a name="Codd1981" href="#Codd1981">Codd1981</a>]</dt>
      <dd>Codd, E.F.&nbsp; Data Models in Database Management.&nbsp; <i>ACM                            
        SIGMOD Record <b>11</b></i>, 2 (Feb. 1981).<br>                           
        &nbsp;&nbsp;&nbsp;</dd>
      <dt>[<a name="Codd1982" href="#Codd1982">Codd1982</a>]</dt>
      <dd>Codd, E.F.&nbsp; The 1981 ACM Turing Award Lecture: Relational                            
        Databases -- A Practical Foundation for Productivity.&nbsp; <i>Comm. ACM                            
        <b>25</b></i>, 2 (February, 1982).<br>                           
        &nbsp;&nbsp;&nbsp;</dd>
      <dt>[<a name="Date2001" href="#Date2001" target="_top">Date2001</a>]</dt>
      <dd>Date, C.J.&nbsp; <i>The Database Relational Model: A Retrospective              
        Review and Analysis</i>. Addison-Wesley (Reading, MA: 2001).&nbsp; ISBN              
        0-201-61294-1 pbk.&nbsp; A historical account and assessment of E. F.              
        Codd's contribution to the field of database technology.<small><br>             
        </small><small>&nbsp;&nbsp;&nbsp;&nbsp; &quot;This book consists in             
        essence of a series of twelve articles, originally published in the             
        print and online portions of the Miller Freeman magazine <i><a href="http://www.intelligententerprise.com/" target="_top">Intelligent             
        Enterprise</a></i> (Vol. <b><i>1</i></b>, Nos. 1-3, and vol.<b><i>2</i></b>,             
        Nos. 1-9, October 1998 onward).</small><small>&nbsp; The overall title             
        for the series was '30 Years of Relational,' ... to celebrate the             
        relational model's 30th birthday ... [and] to serve as a historical             
        account and impartial analysis of E. F. Codd's (huge!) contribution to             
        the field of database technology ... with a view to assessing their true             
        significance and restating (and reinforcing) their message for a new             
        generation of database professionals.&quot;&nbsp; -- from the Preface.<br>            
        &nbsp;&nbsp; Content<br>            
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Preface</i><br>            
        &nbsp;&nbsp;&nbsp;&nbsp; 1. The Birth of the Relational Model, Part 1 [<a href="http://www.intelligententerprise.com/db_area/archives/1998/9810/feat4.shtml" target="_top">October             
        1998</a>]<br>
        &nbsp;&nbsp;&nbsp;&nbsp; 2. The Birth of the Relational Model, Part 2<br>            
        &nbsp;&nbsp;&nbsp;&nbsp; 3. The Birth of the Relational Model, Part 3 [<a href="http://www.intelligententerprise.com/db_area/archives/1998/9812/online1.shtml" target="_top">December             
        1998</a>]<br>
        &nbsp;&nbsp;&nbsp;&nbsp; 4. Codd's Relational Algebra [<a href="http://www.intelligententerprise.com/db_area/archives/1999/990501/online.shtml">January             
        5, 1999</a>]<br>
        &nbsp;&nbsp;&nbsp;&nbsp; 5. Codd's Relational Calculus<br>            
        &nbsp;&nbsp;&nbsp;&nbsp; 6. Data Sublanguage ALPHA, Part 1 [<a href="http://www.intelligententerprise.com/db_area/archives/1999/991602/online2.shtml" target="_top">February             
        16, 1999</a>]<br>
        &nbsp;&nbsp;&nbsp;&nbsp; 7. Data Sublanguage ALPHA, Part 2 [<a href="http://www.intelligententerprise.com/db_area/archives/1999/990903/online2.shtml">March             
        9, 1999</a>]<br>
        &nbsp;&nbsp;&nbsp;&nbsp; 8. The First Three Normal Forms, Part 1 [<a href="http://www.intelligententerprise.com/db_area/archives/1999/993003/online2.shtml" target="_top">March             
        30, 1999</a>]<br>
        &nbsp;&nbsp;&nbsp;&nbsp; 9. The First Three Normal Forms, Part 2 [<a href="http://www.intelligententerprise.com/db_area/archives/1999/992004/online2.shtml" target="_top">April             
        20, 1999</a>]<br>
        &nbsp;&nbsp;&nbsp;&nbsp; 10. Relational Really Is Different [<a href="http://www.intelligententerprise.com/db_area/archives/1999/991105/online2.shtml" target="_top">May             
        11, 1999</a>]<br>
        &nbsp;&nbsp;&nbsp;&nbsp; 11. Extending the Relational Model [<a href="http://www.intelligententerprise.com/db_area/archives/1999/990106/online1.shtml" target="_top">June             
        1, 1999</a>]<br>
        &nbsp;&nbsp;&nbsp;&nbsp; 12. Relational Forever! [<a href="http://www.intelligententerprise.com/db_area/archives/1999/992206/online1.shtml" target="_top">June             
        22, 1999</a>]<br>
        &nbsp;&nbsp;&nbsp;&nbsp; Appendix A. A Definition of the Relational             
        Model<br>
        &nbsp;&nbsp;&nbsp;&nbsp; Appendix B. References and Bibliography<br>            
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Index<br>    
        &nbsp;&nbsp;&nbsp;</i></small></dd>        
      <dt>[<a name="Dawson2000" target="_top" href="#Dawson2000">Dawson2000</a>]</dt>
      <dd>Dawson, Christian W.&nbsp; <i>The Essence of Computing Projects: A    
        Student's Guide</i>.&nbsp; Pearson Education (Harlow, England:    
        2000).&nbsp; ISBN 0-13-021972-X pbk.<small><br />  
        &nbsp;&nbsp; Content<br> 
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Preface</i><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1. Introduction: 
        What Are Computing Projects?<br>
        &nbsp;&nbsp;&nbsp;&nbsp; Part I: Setting Your Project's Foundation<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2. Choosing a 
        Project and Writing a Proposal<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3. Project 
        Planning<br>
        &nbsp;&nbsp;&nbsp;&nbsp; Part II: Conducting Your Project<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4. Literature 
        Searching and Literature Reviews<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5. Doing Your 
        Project<br>
        &nbsp;&nbsp;&nbsp;&nbsp; Part III: Presenting Your Project<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6. Presenting 
        Your Project in Written Form<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7. Presentation 
        Skills<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8. Final 
        Considerations<br>
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Bibliography<br>
        &nbsp;&nbsp;&nbsp;&nbsp; Index</i><br /> 
        &nbsp;&nbsp;&nbsp;</small></dd>
      <dt>[<a name="DeMoor1997" href="#DeMoor1997">DeMoor1997</a>]</dt>                   
      <dd>Bird, Richard., de Moor, Oege.&nbsp; <i>Algebra of Programming</i>.&nbsp;                                                       
        Prentice-Hall (Harlow, England: 1997).&nbsp; ISBN 0-13-507245-X.&nbsp;                                                       
        See [<a href="#[Bird1997]">Bird1997</a>]<br>                                                
        &nbsp;&nbsp;&nbsp;</dd>
 
      <dt>[<a name="Denning2025" href="#Denning2025">Denning2025</a>]</dt>
		<dd>Denning, Peter J. Abstractions.&nbsp; Profession of IT column.&nbsp;
		<i>Comm. ACM <b>68</b></i>, 3 (March 2025), 21-23.<font size="-1">
 
      </font><font size="2"><a href="https://doi.org/10.1145/3710809">
		DOI:10.1145/3710809</a></font></dd>
      <dt>&nbsp;</dt>
		<dt>[<a name="Earley1970" href="#Earley1970">Earley1970</a>]</dt>
		<dd>Earley, Jay., Sturgis, Howard. A Formalism for Translator 
		Interactions.&nbsp; <i>Comm. ACM <b>13</b></i>, 10 (October 1970), 
		607-617.<br>
		<font size="2">&nbsp;&nbsp; I became a strong fan of this kind of 
		diagramming technique, but in the simpler form of [<a href="#Bratman1961">Bratman1961</a>], 
		by which I have also managed to blend into the use of dataflow and HIPO 
		diagrams as well.<br>
		</font>&nbsp;&nbsp;&nbsp;&nbsp; </dd>
		<dt>[<a name="Ershov1972" href="#Ershov1972">Ershov1972</a>]</dt>        
      <dd>Ershov, Andrei P.&nbsp; Aesthetics and the Human Factor in                                             
        Programming.&nbsp; <i>Comm. ACM <b>15</b></i>, <a href="http://portal.acm.org/toc.cfm?id=361454&amp;type=issue&amp;coll=GUIDE&amp;dl=GUIDE&amp;CFID=9042662&amp;CFTOKEN=96407985">7</a>                                             
        (July 1972), 501-505.&nbsp; Archived on-line at <a href="http://doi.acm.org/10.1145/361454.361458" target="_top"><code>http://doi.acm.org/10.1145/361454.361458</code></a>.<small><br>                                       
        </small><small>&nbsp;&nbsp;&nbsp;&nbsp; This is a wonderful find in the references of [<a href="#[Knuth1974]" target="_self">Knuth1974</a>].&nbsp;                                         
        I had read the article when it first appeared, but it lands much more                                         
        clearly for me on rereading it now.&nbsp; Andrei Ershov was a renowned                                         
        computer scientist in Novosobirsk.&nbsp; That he could observe this                                         
        about the situation of programmers worldwide over 30 years ago                                         
        demonstrates to me how out-of-balance our progress has been.&nbsp; I                                         
        don't want to diminish the substantial ground we have covered, yet it is                                         
        valuable to notice that we are dealing with essentially the same issues                                         
        and that our tools don't save us. -- dh:2003-03-22<br>                                       
        &nbsp;&nbsp;&nbsp;</small></dd>      
      <dt>[<a name="Evans1961" href="#Evans1961">Evans1961</a>]</dt>
		<dd>Evans, A., Perlis, A.J., Van Zoeren, H.&nbsp; The Use of Threaded 
		Lists in Construction of a Combined ALGOL and Machine-Like Assembly 
		Processor. <i>&nbsp;Comm. ACM</i> <b>4</b>, 1 (Jan. 1961), 36-41.&nbsp; 
		DOR &lt;<a href="https://dl.acm.org/doi/10.1145/366062.366081">https://dl.acm.org/doi/10.1145/366062.366081</a>&gt;.
		<br>
		<font size="2">Footnote 2 on p.37 describes &quot;mindelayscandoer&quot; as &quot;scan 
		and do translation to final code as quickly as possible.&quot; The idea of 
		threaded lists does not apply well to oMiser, although a counterpart 
		might assist in oFrugal operator-precedence handling.&nbsp; The oFrugal 
		REPL is a true mindelayscandoer.</font><br>
&nbsp;&nbsp;&nbsp; </dd>
		<dt>[<a name="Fagan1979" href="#Fagan1979">Fagan1979</a>]</dt>
		<dd>Fagin, Ronald., Nievergelt, Jurg., Strong, H. Raymond.&nbsp; 
		Extendible Hashing -- A Fast Access Method for Dynamic Files.&nbsp; <i>
		ACM Transactions on Database Systems <b>4</b></i>, 3 (September 1979), 
		315-344.<br>
		<font size="2">&nbsp;&nbsp; This is a foundational paper that is cited 
		in the contributions of others such as [<a href="#Litwin1980">Litwin1980</a>] 
		and [<a href="#Larson1988">Larson1988</a>].&nbsp; It attends to factors, 
		such as processor paging and caching considerations that might not be of 
		such concern in relatively moderate applications.&nbsp; The emphasis is 
		on structuring data whose volume is allowed to grow and shrink by large 
		factors on a dynamic basis.&nbsp; There is a good summary of approaches 
		and characteristics of dynamic file organization schemes.&nbsp; Not all 
		of this pertains to in-memory directories/repositories.&nbsp; It is 
		presumed that the data items being organized are relatively larger than 
		the items in the directory.&nbsp; There is useful nomenclature: The key 
		space, S, is whatever differentiates the items to be captured in the 
		directory.&nbsp; The hash function h on S maps into address space A 
		which is presumed to be fairly evenly distributed.&nbsp; A is mapped 
		onto a directory with buckets having approximately the same high load 
		factor.&nbsp; The notion of load factor is also specified.&nbsp; There 
		is reference to a &quot;buddy&quot; system for allocating buckets [<a href="#Knuth1997">Knuth1997</a>:2.5C].&nbsp; 
		The basic idea of splitting buckets in half or coalescing pairs of 
		sparse buckets into one is fundamental to the proposal, and subsequent 
		proposals, such as Linear Hashing, although it is not done with adjacent 
		(i.e. buddy) blocks and alternative ways might be needed.&nbsp; Part of 
		the buddy system appeal is that it accomodates chunks of different 
		(power of 2) sizes, so it is about allocating other things than, say, 
		simple list-processing cells.&nbsp; Linear Hashing is about splitting 
		and coalescing fixed buckets of directory entries, not necessarily of 
		the extent of an item, just its directory entry.&nbsp; In designing a 
		memory-management system, the various schemes must be walked through 
		very carefully, with testing and instrumentation as well.&nbsp; And 
		there needs to be some smoothness of operation as well as amortization 
		of the burps all such schemes have.<br>
		</font>&nbsp;&nbsp; </dd>
		<dt>[<a name="Gabriel1985" href="#Gabriel1985">Gabriel1985</a>]</dt>
		<dd>Gabriel, Richard P. Performance and Evaluation of Lisp Systems.&nbsp; 
		MIT Press (Cambridge MA: 1985).&nbsp; ISBN 9780262256193.&nbsp; &lt;<a href="https://doi.org/10.7551/mitpress/5298.001.0001">doi.org:10.7551/mitpress/5298.001.0001</a>&gt;.<br>
&nbsp;&nbsp; This book is cited for some benchmarks that it includes, including 
		the &quot;Boyer Test.&quot;&nbsp; Although the subject is a Functional Programming 
		system, this is about implementations and relevant Computer Science 
		Topics and not so abstract as general Functional Programming 
		application.<br>
&nbsp;&nbsp; From the abstract: &quot;This final report of the Stanford Lisp 
		Performance Study, conducted over a three year period by the author, 
		describes implementation techniques, performance tradeoffs, benchmarking 
		techniques, and performance results for all of the major Lisp dialects 
		in use today. ... It provides detailed performance informatoin using the 
		tools of benchmarking (the process of utilizing standardized computer 
		programs to test the processing power of different computer systems) to 
		measure the various Lisp sytems, and provide an understanding of the 
		technical tradeoffs made during the implementation of a Lisp system.&nbsp; 
		The study is divided into three major parts.&nbsp; The first provides 
		the theoretical background, outlining the factors that go into 
		evaluating the performance of a Lisp system.&nbsp; The second part 
		presents the Lisp implmementations ... A final part describes the 
		benchmark suite that was used during the major portion of the study and 
		the results themselves.&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp; </dd>
		<dt>[<a name="Graham1987" href="#Graham1987">Graham1987</a>]</dt>             
      <dd>Ashenhurst, Robert L., Graham, Susan L. (eds.).&nbsp; <i>ACM Turing Award                                                 
        Lectures: The First Twenty Years 1966-1985</i>.&nbsp; ACM Anthology                                                  
        Series.&nbsp; ACM Press (New York: 1987).&nbsp; ISBN 0-201-07794-9.&nbsp;                                                
        See [<a href="#[Ashenhurst1987]">Ashenhurst1987</a>]<small><br>                                               
        &nbsp;&nbsp;&nbsp;</small></dd>           
      <dt>[<a name="Graham1989" href="#Graham1989">Graham1989</a>]</dt>                                                        
      <dd><a href="http://www-cse.ucsd.edu/users/rgraham/" target="_top">Graham, Ronald L.</a>,                                                        
        <a href="http://www-cs-faculty.stanford.edu/~knuth/" target="_top"> Knuth, Donald E.</a>, Patashnik, Oren.&nbsp;                                                        
        <i><a href="http://www-cs-faculty.stanford.edu/~knuth/gkp.html" target="_top">Concrete                    
        Mathematics: A Foundation for Computer Science</a></i>.&nbsp; <a href="http://www.aw.com" target="_top">Addison-Wesley</a>                                                        
        (Reading, MA: 1989).&nbsp; ISBN 0-201-14236-8.<font size="-1"><br>                                                        
        &nbsp;&nbsp; Content<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Preface<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; A Note on Notation</i><br>                    
        &nbsp;&nbsp;&nbsp;&nbsp; 1. Recurrent Problems<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; 2. Sums<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; 3. Integer Functions<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; 4. Number Theory<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; 5. Binomial Coefficients<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; 6. Special Numbers<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; 7. Generating Functions<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; 8. Discrete Probability<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; 9. Asymptotics<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; Appendix A.&nbsp; Answers to Exercises<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; Appendix B. Bibliography<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; Appendix C. Credits for Exercises<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Index<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; List of Tables<br>                                               
        &nbsp;&nbsp;&nbsp;</i></font></dd>                   
      <dt>[<a name="Gulutzan1999" href="#Gulutzan1999">Gulutzan1999</a>]</dt>
      <dd>Gulutzan, Peter., Pelzer, Trudy.&nbsp; <i>SQL-99 Complete, Really:</i>                      
        An Example-Based Reference Manual of the New Standard.&nbsp; R&amp;D                      
        Books Miller Freeman (Lawrence KS: 1999).&nbsp;&nbsp; ISBN 0-87930-568-1                      
        pbk + CD-ROM.&nbsp; See [<a href="infoware.htm#Gulutzan1999">Gulutzan1999</a>]                
        under <a href="infoware.htm">Information Processing</a>.<small><br>               
        &nbsp;&nbsp;&nbsp;</small></dd>
      <dt>[<a name="Hamming1969" href="#Hamming1969">Hamming1969</a>]</dt>      
      <dd>Hamming, R.W.&nbsp; One Man's View of Computer Science.&nbsp;<i> J.                                            
        ACM <b>16</b></i>, <a href="http://portal.acm.org/toc.cfm?id=321495&amp;type=issue&amp;coll=GUIDE&amp;dl=GUIDE&amp;CFID=9036156&amp;CFTOKEN=77952128" target="_top"> 1</a> (Jan. 1969), 3-12.&nbsp; Archived on-line at                                   
        <a href="http://doi.acm.org/10.1145/321495.321497" target="_top"><code>http://doi.acm.org/10.1145/321495.321497</code></a>.&nbsp;                                           
        Reprinted in [<a href="#[Ashenhurst1987]">Ashenhurst1987</a>:                                           
        pp.207-218].<small><br>      
        &nbsp;&nbsp;&nbsp;&nbsp; &quot;A number of observations and comments are                                            
        directed toward suggesting that more than the usual engineering flavor                                            
        be given to computer science. The engineering aspect is important                                            
        because most present difficulties in this field do not involve the                                            
        theoretical question of whether certain things can be done, but rather                                            
        the practical question of how can they be accomplished well and simply.</PAR>                                           
        <PAR>                                           
        <br>       
        &nbsp;&nbsp;&nbsp;&nbsp; &quot;The teaching of computer science could be                                            
        made more effective by various alterations, for example, the inclusion                                            
        of a laboratory course in programming, the requirement for a strong                                            
        minor in something other than mathematics, and more practical coding and                                            
        less abstract theory, as well as more seriousness and less game                                            
        playing.&quot; -- from the Abstract<br>                                           
        &nbsp;&nbsp;&nbsp;</small></dd>
		<dt>[<a name="Hayes2025" href="#Hayes2025">Hayes2025</a>]</dt>
		<dd>Hayes, Catherine., Malone, David.&nbsp; Questioning the Criteria for 
		Evaluating Non-Cryptographic Hash Functions.&nbsp; <i>Comm. ACM <b>68</b></i>, 
		2 (Feb. 2025), 46-51.<br>
&nbsp;&nbsp; <font size="2">This is an interesting study around conditions that 
		apply for non-cryptographic hash functions, ones where the concern is 
		how well a items from a given distribution distribute into distinct 
		buckets with minimal clumping.&nbsp; The paper does not address the 
		historically-common case of hashes used on fixed vocabularies, such as 
		symbol tables, and whether or not the order in which items are first 
		hashed can have any material impact, especially when arrivals are not 
		uniformly distributed.&nbsp; An interesting topic would be 
		reconciliation of the cases here and the considerations of [<a href="#Knuth1998b">Knuth1998b</a>:6.4].<br>
&nbsp;&nbsp; </font></dd>
		<dt>[<a name="Hewitt1983" href="#Hewitt1983">Hewitt1983</a>]</dt>
		<dd>Lieberman, Henry., Hewitt, Carl.&nbsp; A real-time garbage collector 
		based on the lifetimes of objects.&nbsp; <i>Comm. ACM<b> 26</b></i>, 6 
		(June 1983), 419-429.&nbsp; See [<a href="#Lieberman1983">Lieberman1983</a>]</dd>
      <dt>&nbsp;&nbsp; </dt>
		<dt>[<a target="_top" name="Kent1982" href="#Kent1982">Kent1982</a>]</dt>
      <dd><a href="http://www.bkent.net/" target="_top">Kent, William</a>.&nbsp;                        
        <a href="http://www.bkent.net/Doc/simple5.htm" target="_top">A Simple  
        Guide to Five Normal Forms in Relational Database Theory</a>. <i>Comm.                        
        ACM <b>26</b></i>, 2 (Feb. 1983), <a href="http://doi.acm.org/10.1145/358024.358054" target="_top">120-125</a>.                        
        Also IBM Technical Report TR03.159, Aug. 1981. Also presented at SHARE                        
        62, March 1984, Anaheim, California. Also in A.R. Hurson, L.L. Miller                        
        and S.H. Pakzad, <i> Parallel Architectures for Database Systems</i>, IEEE                        
        Computer Society Press, 1989.<br>                       
        &nbsp;&nbsp;&nbsp;</dd>
      <dt>[<a name="Kent2000" href="#Kent2000" target="_top">Kent2000</a>]</dt>   
      <dd><a href="http://www.bkent.net/">Kent, William</a>.&nbsp; <i><a href="http://www.bkent.net/Doc/darxrp.htm" target="_top">Data                       
        and Reality</a></i>.&nbsp; ed.2.&nbsp; <a href="http://www.1stbooks.com/" target="_top">The                       
        International Online Library</a>.&nbsp; (Bloomington, IN: 1978; 1998,                       
        2000).&nbsp; ISBN 1-58500-970-9.<small><br>                      
        &nbsp;&nbsp; Content<br>                      
        &nbsp;&nbsp;&nbsp;&nbsp; Preface to the Second Edition<br>                     
        &nbsp;&nbsp;&nbsp;&nbsp; Preface<br>                     
        &nbsp;&nbsp;&nbsp;&nbsp; 1. Entities<br>                     
        &nbsp;&nbsp;&nbsp;&nbsp; 2. The Nature of an Information System<br>                     
        &nbsp;&nbsp;&nbsp;&nbsp; 3. Naming<br>                     
        &nbsp;&nbsp;&nbsp;&nbsp; 4. Relationships<br>                     
        &nbsp;&nbsp;&nbsp;&nbsp; 5. Attributes<br>                     
        &nbsp;&nbsp;&nbsp;&nbsp; 6. Types and Categories and Sets<br>                     
        &nbsp;&nbsp;&nbsp;&nbsp; 7. Models<br>                     
        &nbsp;&nbsp;&nbsp;&nbsp; 8. The Record Model<br>                     
        &nbsp;&nbsp;&nbsp;&nbsp; 9. The Other Three Popular Models<br>                     
        &nbsp;&nbsp;&nbsp;&nbsp; 10. The Modeling of Relationships<br>                     
        &nbsp;&nbsp;&nbsp;&nbsp; 11. Elementary Concepts: Another Model?<br>                     
        &nbsp;&nbsp;&nbsp;&nbsp; 12. Philosophy<br>                     
        &nbsp;&nbsp;&nbsp;&nbsp; Bibliography<br>                     
        &nbsp;&nbsp;&nbsp;&nbsp; Detailed Contents<br>                     
        &nbsp;&nbsp;&nbsp;</small></dd>
      <dt>[<a name="Knuth1961" href="#Knuth1961">Knuth1961</a>]</dt>                 
      <dd><a href="http://www-cs-faculty.stanford.edu/~knuth/" target="_top">Knuth, Donald E</a>.&nbsp;                                             
        Minimizing Drum Latency Time.&nbsp; <i>J. ACM <b>8</b></i>, <a href="http://portal.acm.org/toc.cfm?id=321062&amp;type=issue&amp;coll=GUIDE&amp;dl=GUIDE&amp;CFID=9042706&amp;CFTOKEN=91523524">2</a>                                             
        (April 1961), 119-150.&nbsp; Archived on-line at <a href="http://doi.acm.org/10.1145/321062.321063" target="_top"><code>http://doi.acm.org/10.1145/321062.321063</code></a>.<br>                                           
        &nbsp;&nbsp;&nbsp;</dd>        
      <dt>[<a name="Knuth1974" href="#Knuth1974">Knuth1974</a>]</dt>                  
      <dd><a href="http://www-cs-faculty.stanford.edu/~knuth/" target="_top">Knuth, Donald E</a>.&nbsp; Computer Programming as an Art.&nbsp; 
		<a href="https://amturing.acm.org/award_winners/knuth_1013846.cfm">1974                                               
        Turing Award</a> Lecture.&nbsp; <i>Comm.                                               
        ACM <b>17</b></i>, <a href="http://portal.acm.org/toc.cfm?id=361604&amp;type=issue&amp;coll=portal&amp;dl=ACM&amp;CFID=9020381" target="_top">                                             
        12</a> (Dec. 1974), 667-673.&nbsp; Reprinted in pp. 33-46 of [<a href="#[Ashenhurst1987]" target="_self">Ashenhurst1987</a>]                                               
        and in Chapter 1 of [<a href="#[Knuth1992]" target="_self">Knuth1992</a>].&nbsp;                                             
        Archived on-line at <a href="http://doi.acm.org/10.1145/361604.361612" target="_top"><code>http://doi.acm.org/10.1145/361604.361612</code></a>.<br>                                             
        &nbsp;&nbsp;&nbsp;</dd>          
      <dt>[<a name="Knuth1989" href="#Knuth1989">Knuth1989</a>]</dt>                                                        
      <dd>Graham, Ronald L., <a href="http://www-cs-faculty.stanford.edu/~knuth/" target="_top">Knuth, Donald                                             
        E.</a>, Patashnik, Oren.&nbsp; <i>Concrete                                                        
        Mathematics: A Foundation for Computer Science</i>.&nbsp; Addison-Wesley                                                        
        (Reading, MA: 1989).&nbsp; ISBN 0-201-14236-8.&nbsp; See [<a href="#[Graham89]">Graham1989</a>]</dd>                                                        
      <dt>&nbsp;</dt>                    
      <dt>[<a name="Knuth1992" href="#Knuth1992">Knuth1992</a>]</dt>                                                        
      <dd><a href="http://www-cs-faculty.stanford.edu/~knuth/" target="_top">Knuth, Donald E</a>. ¬´<i><a href="http://www-cs-faculty.stanford.edu/~knuth/lp.html" target="_top">Literate Programming</a></i>¬ª.&nbsp; CSLI Lecture                                                        
        Notes Number 27.&nbsp; Center for the Study of Language and Information                                                        
        (Palo Alto: 1992).&nbsp; ISBN 0-937073-80-6 pbk.<font size="-1"><br>                                                        
        &nbsp;&nbsp; Content<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp;<i> Acknowledgments<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp; Preface</i><br>                    
        &nbsp;&nbsp;&nbsp;&nbsp; 1. Computer Programming as an Art [A.M. Turing                                                        
        Award Lecture, <a href="#[Knuth1974]" target="_self">1974</a>]<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp; 2. Structured Programming with <b><code>goto</code></b>                                                        
        Statements [1974]<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; 3. A Structured Program to Generate All                                                        
        Topological Sorting Arrangements [with Jayme L. Szwarcfiter, 1974]<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; 4. Literate Programming [1984]<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; 5. Programming Pearls, by Jon Bentley: Sampling                                                        
        [1986]<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp; 6. Programming Pearls, Continued: Common Words                                                        
        [1986]<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp; 7. How to Read a </font> <code><span style="letter-spacing: -1pt">WEB</span></code> <font size="-1"> [1986]<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; 8. Excerpts from the Programs for <span style="letter-spacing: -1pt"> &Tau;<sub>&Epsilon;</sub>&Chi;</span>                                                        
        and <font face="Arial Rounded MT Bold, Arial, Helvetica, Geneva, Swiss, Sans Serif"><b>METAFONT</b></font> [1986]<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; 9. Mathematical Writing [1987]<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; 10. The Errors of <span style="letter-spacing: -1pt"> &Tau;<sub>&Epsilon;</sub>&Chi;</span>                                                        
        [1989]<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; 11. The Error Log of <span style="letter-spacing: -1pt"> &Tau;<sub>&Epsilon;</sub>&Chi;</span>                                                        
        [1991]<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; 12. An Example of </font><code><span style="letter-spacing: -1pt">CWEB</span></code><font size="-1">                                                        
        [1990]<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Further Reading<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; Index</i></font></dd>                                                        
      <dd>&nbsp;</dd>                    
      <dt>[<a name="Knuth1993" href="#Knuth1993">Knuth1993</a>]</dt>   
      <dd> <a href="http://www-cs-faculty.stanford.edu/~knuth/" target="_top"> Knuth, Donald E</a>.&nbsp; Artistic :Programming.&nbsp; This Week's                                        
        Citation Classic.&nbsp; <i>Current Contents, Physical, Chemical &amp;                                        
        Earth Sciences <b>33</b></i>, 34 (23 August 1993), 8.&nbsp; Reprinted in                                        
        [<a href="#Knuth1996" target="_self">Knuth1996</a>: Chapter 15].<small><br>                                       
        &nbsp;&nbsp;&nbsp;&nbsp; This short article provides some interesting                                        
        context on the writing of the <i>Art of Computer Programming </i>[ACP:                                        
        now [<a href="#Knuth1997" target="_self">Knuth1997</a>], [<a href="#[Knuth1998]" target="_self">Knuth1998</a>],                                        
        [<a href="#[Knuth1998b]" target="_self">Knuth1998b</a>], and subsequent volumes and                                        
        revisions to appear].&nbsp;&nbsp; In the summer of 1962 I was on the                                       
        Univac team for which Don developed a small Fortran compiler using the                                       
        small-compiler techniques that he and others had mastered.&nbsp; There is                                       
        also a hint of the degree to which Knuth pursues beauty in his work and                                       
        as something to preserve in the world, including his 11-year effort to                                       
        restore mathematical typography, an ultimate tool-building act.&nbsp; --                                       
        dh:2003-03-22<br>  
        &nbsp;&nbsp;&nbsp;</small></dd>
		<dt>[<a name="Knuth1993b" href="#Knuth1993b">Knuth1993b</a>]</dt>
		<dd> <a href="http://www-cs-faculty.stanford.edu/~knuth/" target="_top"> Knuth, Donald E</a>.
		<i>The Stanford GraphBase: A Platform for Combinatorial Computing</i>.&nbsp; 
		Addison-Wesley (Boston: 1963).&nbsp; ISBN 978-0-321-60632-7 pbk.<br>
		<font size="2">&nbsp;&nbsp; &quot;This award-winning book demonstrates the 
		art of <a href="https://www-cs-faculty.stanford.edu/~knuth/lp.html">
		literate programming</a> with more than 30 examples. ... The programs 
		contain state-of-the-art explanations of many important algorithms and 
		data structures.&nbsp; They also define a workbench for combinatorial 
		computing, and standard sets of data that can be used for benchmark 
		tests of computing methods, as well as demonstration programs and games 
		that make use of the data.&quot; (<a href="https://www-cs-faculty.stanford.edu/~knuth/sgb.html">Author&#39;s 
		note</a> with additional information including Errata and considerations 
		that impact x64 implementations.)<br>
&nbsp;&nbsp; <a href="https://github.com/ascherer">Andreas Scherer</a> has 
		provided a <a href="https://github.com/ascherer/sgb">GitHub SGB 
		repository</a> based on the 2002-01-30 release of the Stanford GraphBase 
		software and data.&nbsp; Adjustments in the form of patches are provided 
		in separate files there.&nbsp; Orientation is generally toward use on 
		Unix systems, with standard Unix tools.&nbsp; The source programs are 
		all in <font face="Courier New">*.w</font> (Web) files that require a 
		CWeb installation. The code is in C Language, but rather [<a href="authors.htm#Kernighan1988">K&amp;R</a>] 
		classical.&nbsp; Adjustment to more-modern levels of standards (ANSI and 
		ISO) for the C Language are provided in patches.&nbsp; These factors 
		make it important to have the book and learn to read the published form 
		of the Literate Programming documentation (and nicely explained in the 
		book).&nbsp;&nbsp; There are some handy data files for testing the 
		programs and other algorithms that the SGB ones may inspire.</font><br>
&nbsp;&nbsp; </dd>
      <dt>[<a name="Knuth1996" target="_top" href="#Knuth1996">Knuth1996</a>] </dt>                                                        
      <dd> <a href="http://www-cs-faculty.stanford.edu/~knuth/" target="_top"> Knuth, Donald E</a>. <i> <a href="http://www-cs-faculty.stanford.edu/~knuth/cs.html" target="_top"> Selected Papers on Computer Science</a></i>. CSLI                                                        
        Lecture Notes Number 59.&nbsp; Center for the                                                        
    Study of Language and Information (Palo Alto: 1996). ISBN 1-881526-91-7 pbk.<font size="-1"><br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; I opened this up because it                                                        
        contains Don's appreciation of the IBM 650. There is more here,                                                        
        including an example from Bishop's Constructive Analysis (almost on                                                        
        p.100) that put me over the top on the purchase decision.&nbsp; There is                                                        
        much said here about algorithms, and that matters in <a href="http://miser-theory.info/" target="_top"> The Miser                                                        
        Project</a>,                                                        
        too.&nbsp; dh:2000-07-18.<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; For a related discussion, see my note, <a href="2001/r010101.htm">Do                                                       
        Programs Teach Algorithms?</a> -- dh.<br>                                                   
        &nbsp;&nbsp; Content<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Preface<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; Acknowledgments</i><br>                    
        &nbsp;&nbsp;&nbsp;&nbsp; 0. Algorithms, Programs, and Computer Science                                                        
        [1966; 1992]<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; 1. Computer Science and its Relation to                                                        
        Mathematics [1973; 1974]<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; 2. Mathematics and Computer Science: Coping                                                        
        with Finiteness [1976]<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; 3. Algorithms [1977]<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; 4. Algorithms in Modern Mathematics and                                                        
        Computer Science [1981]<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; 5. Algorithmic Themes [1988]<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; 6. Theory and Practice, I [1977]<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; 7. Theory and Practice, II [1985]<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; 8. Theory and Practice, III [1986]<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; 9. Theory and Practice, IV [1989]<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; 10. Are Toy Problems Useful [1977]<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; 11. Ancient Babylonian Algorithms [1972; 1976]<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; 12. Von Neumann's First Computer Program [1970]<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; 13. The IBM 650: An Appreciation from the Field                                          
        [<a href="swe.htm#[Knuth1986]" target="_self">1986</a>]<br>                   
        &nbsp;&nbsp;&nbsp;&nbsp; 14. George Forsythe and the Development of                                                        
        Computer Science [1972]<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; 15. Artistic Programming [<a href="#[Knuth1993]" target="_self">1993</a>]<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Index</i></font></dd>                                                        
      <dt>&nbsp;</dt>                    
      <dt>[<a name="Knuth1997" target="_top" href="#Knuth1997">Knuth1997</a>] </dt>                                                        
      <dd><a href="http://www-cs-faculty.stanford.edu/~knuth/" target="_top">Knuth, Donald E</a>.&nbsp;                                                        
        <i><a href="http://www-cs-faculty.stanford.edu/~knuth/taocp.html" target="_top">The Art of Computer                    
        Programming</a>, vol.1:                    
        Fundamental Algorithms</i>. ed.3.&nbsp; Addison Wesley Longman (Reading,                                                        
        MA: 1968, 1973, 1997).&nbsp; ISBN 0-201-89683-4.<font size="-1"><br>                                                        
        &nbsp;&nbsp; Contents<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Preface<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; Preface to the Third Edition<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp; Procedure for Reading This Set of Books<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp; Notes on the Exercises</i><br>                    
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Chapter 1</i> - Basic Concepts<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.1 Algorithms<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.2 Mathematical                                                        
        Preliminaries<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.3 </font> <code><span style="letter-spacing: -1pt">MIX</span></code><font size="-1"><br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.4 Some                                                        
        Fundamental Programming Techniques<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Chapter 2</i> - Information Structures<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.1 Introduction<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.2 Linear Lists<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.3 Trees<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.4 Multilinked                                                        
        Structures<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.5 Dynamic                                                        
        Storage Allocation<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.6 History and                                                        
        Bibliography<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Answers to Exercises</i><br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Appendix A</i> - Tables of Numerical Quantities<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Appendix B</i> - Index to Notations<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Index and Glossary</i></font></dd>                                                        
      <dt>&nbsp;</dt>                    
      <dt>[<a name="Knuth1998" href="#Knuth1998">Knuth1998</a>] </dt>                                                        
      <dd><a href="http://www-cs-faculty.stanford.edu/~knuth/" target="_top">Knuth, Donald E</a>.&nbsp;                                                        
        <i><a href="http://www-cs-faculty.stanford.edu/~knuth/aa.html" target="_top">The Art of Computer                    
        Programming</a>, vol.2:                    
        Seminumerical Algorithms</i>.&nbsp; ed.3.&nbsp; Addison Wesley Longman                                                        
        (Reading, MA: 1969, 1981, 1998).&nbsp; ISBN 0-201-89684-2.<font size="-1"><br>                                                        
        &nbsp;&nbsp; Content<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Preface<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; Preface to the Third Edition<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp; Notes on the Exercises</i><br>                    
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Chapter 3 </i>- Random Numbers<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.1 Introduction<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.2 Generating                                                        
        Uniform Random Numbers<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.3 Statistical                                                        
        Tests<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.4 Other Types                                                        
        of Random Quantities<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.5 What Is a                                                        
        Random Sequence?<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.6 Summary<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Chapter 4</i> - Arithmetic<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4.1 Positional                                                        
        Number Systems<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4.2 Floating                                                        
        Point Arithmetic<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4.3 Multiple                                                        
        Precision Arithmetic<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4.4 Radix                                                        
        Conversion<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4.5 Rational                                                        
        Arithmetic<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4.6 Polynomial                                                        
        Arithmetic<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4.7 Manipulation                                                        
        of Power Series<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Answers to Exercises</i><br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Appendix A</i> - Tables of Numerical                                                        
        Quantities<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Appendix B</i> - Index to Notations<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Index and Glossary</i></font></dd>                                                        
      <dt>&nbsp;</dt>                    
      <dt>[<a name="Knuth1998b" href="#Knuth1998b">Knuth1998b</a>]</dt>                                                        
      <dd><a href="http://www-cs-faculty.stanford.edu/~knuth/" target="_top">Knuth, Donald E</a>.&nbsp;                                                        
        <i><a href="http://www-cs-faculty.stanford.edu/~knuth/aa.html" target="_top">The Art of Computer                    
        Programming</a>, vol.3:                    
        Sorting and Searching</i>.&nbsp; ed.2.&nbsp; Addison Wesley Longman                                                        
        (Reading, MA: 1973, 1998).&nbsp; ISBN 0-201-89685-0.<font size="-1"><br>                                                        
        &nbsp;&nbsp; Content<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Preface<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; Preface to the Second Edition<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp; Notes on the Exercises<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp; Chapter 5</i> - Sorting<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5.1 Combinatorial                                                        
        Properties of Permutations<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5.2 Internal                                                        
        Sorting<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5.3 Optimum                                                        
        Sorting<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5.4 External                                                        
        Sorting<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5.5 Summary,                                                        
        History, and Bibliography<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp;<i> Chapter 6</i> - Searching<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6.1 Sequential                                                        
        Searching<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6.2 Searching by                                                        
        Comparison of Keys<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6.3 Digital                                                        
        Searching<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6.4 Hashing<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6.5 Retrieval on                                                        
        Secondary Keys<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Answers to Exercises<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; Appendix A</i> - Tables of Numerical Quantities<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Appendix B</i> - Index to Notations<br>                                                        
        &nbsp;&nbsp;&nbsp;&nbsp;<i> Index and Glossary</i></font></dd>                                                        
      <dt>&nbsp;</dt>                    
      <dt>[<a name="Knuth2000" href="#Knuth2000">Knuth2000</a>]</dt>                   
      <dd><a href="http://www-cs-faculty.stanford.edu/~knuth/" target="_top">Knuth, Donald E</a>.&nbsp;                                                        
        <i><a href="http://www-cs-faculty.stanford.edu/~knuth/aa.html" target="_top">Selected                    
        Papers on Analysis of Algorithms</a></i>.&nbsp; CLSI Lecture Notes                                                        
        Number 102.&nbsp; Center for the Study of Language and Information                                                        
        (Palo Alto: 2000).&nbsp; ISBN 1-57586-212-3 pbk.<font size="-1"><br>         
        &nbsp;&nbsp;&nbsp;</font></dd>
		<dt>[<a name="Knuth2011" href="#Knuth2011">Knuth2011</a>]</dt>
		<dd>Knuth, Donald E.&nbsp; <i>Selected Papers on Fun &amp; Games</i>.&nbsp; 
		CSLI Lecture Notes Number 192. CSLI Publications (Stanford, CA: 2011).&nbsp; 
		ISBN 1-57586-584-X pbk.</dd>
		<dt>&nbsp;</dt>
      <dt>[<a name="Kurose2003" target="_top" href="#Kurose2003">Kurose2003</a>]</dt>
      <dd>Kurose, James F., Ross, Keith W.&nbsp; <i><a href="http://www.aw.com/kurose-ross" target="_top">Computer         
        Networking</a>: A Top-Down Approach Featuring the Internet</i>.&nbsp;         
        ed.2, International.&nbsp; <a href="http://www.aw.com/cs" target="_top">Addison-Wesley</a>         
        (Boston, MA: 2003).&nbsp; ISBN 0-321-17644-8 pbk.<small><br>        
        &nbsp;&nbsp;&nbsp;&nbsp; </small><small>This is a textbook.&nbsp; I will        
        be using it for my <a href="../erudizione/M.ScIT/">M.Sc</a> module on        
        Computer Communication beginning 2004-02-05.&nbsp; There is a <a href="http://www.aw.com/kurose-ross" target="_top"> companion web        
        site</a> that provides links, errata, and other materials.&nbsp; It         
        includes additional student resources available to purchasers of the         
        book (via a scratch-off access code bound into the book).&nbsp; The        
        companion material includes self-assessment, some programming        
        assignments, and material from the previous edition.&nbsp;<br>       
        &nbsp;&nbsp;&nbsp;&nbsp; I am also interested in this book with regard        
        to the treatment of abstractions involving computer communication and        
        networking.&nbsp; These are pertinent to <a href="http://nfoWare.com" target="_top"><b><i> nfoWare</i></b></a> and I want to use        
        consistent terminology and concepts where I am able to do so.&nbsp; I        
        will see how that works as I dig into the course.&nbsp; -- dh:2004-01-11<br>       
        &nbsp;&nbsp;&nbsp;&nbsp; Although communication and networking texts       
        don't start at the fundamental level that I see called for in <i><a href="http://nfoWare.com/data/" target="_top">Situating       
        Data</a></i>, this book is rewarding in how it points to meaningful       
        toolcraft for having confirmable experiences with operations of computer       
        communications.&nbsp; I find high value in the gentleness of the       
        progression and in the provision of concrete examples that can be used       
        in experimental confirmation of networking and communication       
        operations.&nbsp; [dh:2004-02-13]<br>      
        &nbsp;&nbsp; Content<br>        
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Preface</i><br>       
        &nbsp;&nbsp;&nbsp;&nbsp; 1. Computer Networks and the Internet<br>        
        &nbsp;&nbsp;&nbsp;&nbsp; 2. Application Layer<br>       
        &nbsp;&nbsp;&nbsp;&nbsp; 3. Transport Layer<br>       
        &nbsp;&nbsp;&nbsp;&nbsp; 4. Network Layer and Routing<br>       
        &nbsp;&nbsp;&nbsp;&nbsp; 5. Link Layer and Local Area Networks<br>       
        &nbsp;&nbsp;&nbsp;&nbsp; 6. Multimedia Networking<br>       
        &nbsp;&nbsp;&nbsp;&nbsp; 7. Security in Computer Networks<br>       
        &nbsp;&nbsp;&nbsp;&nbsp; 8. Network Management<br>       
        &nbsp;&nbsp;&nbsp;&nbsp; <i>References<br>       
        &nbsp;&nbsp;&nbsp;&nbsp; Index</i><br>
        &nbsp;&nbsp;&nbsp;</small></dd>
 
		<dt>[<a name="Larson1988" href="#Larson1988">Larson1988</a>]</dt>
		<dd>Larson, Per-Ake.&nbsp; Dynamic Hash Tables.&nbsp; <i>Comm. ACM <b>31</b></i>, 
		4 (April 1988), 446-457.&nbsp; Available on the Internet at &lt;<a href="https://dl.acm.org/doi/10.1145/42404.42410">https://dl.acm.org/doi/10.1145/42404.42410</a>&gt;.<br>
		<font size="2">&nbsp;&nbsp; From the Abstract: &quot;Linear hashing and 
		spiral storage are two dynamic hashing schemes originally designed for 
		external files.&nbsp; This paper shows how to adapt these two methods 
		for hash tables stored in main memory.&nbsp; The necessary data 
		structures and algorithms are described, the expected performance is 
		analyzed mathematically, and actual execution time are obtained and 
		compared with alternative techniques.&nbsp; Linear hashing is found to 
		be both faster and easier to implement than spiral storage. ... Overall, 
		linear hashing is a simple and efficient technique for applications 
		where the cardinality of the key set is not known in advance.<br>
&nbsp;&nbsp; This article provides a very clear account of Linear Hashing as 
		introduced in [<a href="#Litwin1980">Litwin1980</a>].&nbsp; The data 
		structures and algorithms are well illustrated in a publication form of 
		ALGOL 60/Pascal accompanied by useful diagrams.&nbsp; The design of the 
		experiments and the experimental results are also illustrative and 
		inform what one might to employ Linear Hashing for an in-memory 
		directory/database.&nbsp; It will be important to obtain excellent 
		&quot;representative&quot; test cases.&nbsp; The cardinality observation is about 
		the key set, not the hashes, although the chardinality of the hash 
		values is set in advance and determines the worst case for a very large 
		data set of distinct keys.&nbsp; Also, within the hash set, there will 
		be collisions even in the hopefully-impossible largest case, say 24-32&nbsp; 
		hash bits.</font></dd>
 
      <dt>&nbsp;&nbsp; </dt>
		<dt>[<a name="Lieberman1983" href="#Lieberman1983">Lieberman1983</a>]</dt>
		<dd>Lieberman, Henry., Hewitt, Carl.&nbsp; A real-time garbage collector 
		based on the lifetimes of objects.&nbsp; <i>Comm. ACM<b> 26</b></i>, 6 
		(June 1983), 419-429.<br>
&nbsp;&nbsp; This paper reviews the technique of [<a href="#Baker1978">Baker1978</a>] 
		and proposes a simple extension to have multiple generations (smaller 
		regions) and a scavenging technique that ensures all references into a 
		region being evacuated are not left dangling.&nbsp; Finding a reference 
		must be done to accomplish the vacating of the referenced object and let 
		the new location be know to all of the references to any one of them.<br>
&nbsp;&nbsp; [dh:2025-11-22 I am not sanguine about all of this.&nbsp; In the 
		case of list structures that are always acyclic and (logically) 
		immutable, this may be far easier.&nbsp; I need to understand how 
		forward pointers are needed in this Lieberman-Hewitt scheme and if I can 
		always avoid them.]<br>
&nbsp;&nbsp; </dd>
		<dt>[<a name="Litwin1980" href="#Litwin1980">Litwin1980</a>]</dt>
		<dd>Litwin, Witold. Linear Hashing: A New Tool for File and Table 
		Addressing.&nbsp; pp.212-223 in <i>Proceedings of the 6th International 
		Conference on Very Large Databases (VLDB)</i>, (Montreal, Quebec, 
		Canada: October 1980).&nbsp; Available on the Internet at &lt;<a href="https://cs-web.bu.edu/faculty/gkollios/ada17/LectNotes/linear-hashing.PDF">https://cs-web.bu.edu/faculty/gkollios/ada17/LectNotes/linear-hashing.PDF</a>&gt;.<br>
		<font size="2">&nbsp;&nbsp; From the Abstract: &quot;Linear hashing is a 
		hashing in which the address space may grow or shrink dynamically. A 
		file or a table may then support <i>any</i> number of insertions or 
		deletions wthout access or memory load performance deterioration.&nbsp; 
		A record in the file is, in general, found in <i>one</i> access while 
		the load may stay practically constant up to 90%.&nbsp; A record in a 
		table is found in a mean of 1.7 accesses, while the load is constantly 
		80%.&nbsp; No other algorithms attaining such a performance are known.&quot;<br>
&nbsp;&nbsp; In April 2011 I stumbled over Linear Hashing in the context of a 
		patent-infringement held against Google in regard to a means for 
		accomplishing deletions of somehow-expired entries while searching for 
		something in the bucket used for similar hashes.&nbsp; Avoiding that 
		situation, the use of Linear Hashing is very appealing in how the table 
		of hash-indexed items grows and maybe even shrinks dynamically.&nbsp; 
		There are related considerations concerning the nature of the hash 
		values and also their distribution in accesses to a 
		Linear-Hashing-implemented directory/database.<br>
		</font>&nbsp;&nbsp; </dd>
		<dt>[<a name="Malone2025" href="#Malone2025">Malone2025</a>]</dt>
		<dd>Hayes, Catherine., Malone, David.&nbsp; Questioning the Criteria for 
		Evaluating Non-Cryptographic Hash Functions.&nbsp; <i>Comm. ACM <b>68</b></i>, 
		2 (Feb. 2025), 46-51.&nbsp; See [<a href="#Hayes2025">Hayes2025</a>]<br>
&nbsp;&nbsp; </dd>
 
      <dt>[<a name="Matula1968" href="#Matula1968">Matula1968</a>]<dd>Matula, 
		David W.&nbsp; In-and-Out Conversions.&nbsp; <i>Comm. ACM <b>11</b></i>, 
		1 (January 1968), 47-50.&nbsp; &lt;<a href="https://doi.org/10.1145/362851.362887">doi:10.1145/362851.362887</a>&gt;<br>
&nbsp;&nbsp; Abstract: &quot;By an in-and-out coversion we mean that a floating-point 
		number in one base is converted into a floating-point number in another 
		base and then converted back to a floating-point number in the original 
		base.&nbsp; For all combinations of rounding and truncation conversions, 
		the question is considered of how many significant digits are needed in 
		the intermediate base to allow such in-and-out conversions to return the 
		original number (when possible), or at least to ccause a difference of 
		no more than a unit in the least significan digit.&quot;<br>
&nbsp;&nbsp; </dd>
		<dt>[<a name="More1979" href="#More1979">More1979</a>]</dt>
      <font size="-1">
 
      <dd>More, Trenchard. The nested rectangular array as a model of data. pp. 
		55-73 in &quot;APL &#39;79 Proceedings of the international conference on APL: 
		Part 1.&quot; doi&gt;10.1145/390009.804440 available at<br>
		&lt;<a href="https://dl.acm.org/citation.cfm?id=804440">https://dl.acm.org/citation.cfm?id=804440</a>&gt;<br>
&nbsp;&nbsp;&nbsp;
    </font></dd>
		<dt>[<a name="Nievergelt1979" href="#Nievergelt1979">Nievergelt1979</a>]</dt>
		<dd>Fagin, Ronald., Nievergelt, Jurg., Strong, H. Raymond.&nbsp; 
		Extendible Hashing -- A Fast Access Method for Dynamic Files.&nbsp; <i>
		ACM Transactions on Database Systems <b>4</b></i>, 3 (September 1979), 
		315-344.&nbsp; See [<a href="#Fagan1979">Fagan1979</a>]</dd>
		<dt>&nbsp;&nbsp; </dt>
		<dt>[<a name="Patashnik1989" href="#Patashnik1989">Patashnik1989</a>]</dt>                                                        
      <dd>Graham, Ronald L., Knuth, Donald E., Patashnik, Oren.&nbsp; <i>Concrete                                                        
        Mathematics: A Foundation for Computer Science</i>.&nbsp; Addison-Wesley                                                        
        (Reading, MA: 1989).&nbsp; ISBN 0-201-14236-8.&nbsp; See [<a href="#[Graham1989]">Graham1989</a>]<br>                               
        &nbsp;&nbsp;&nbsp;</dd>                        
      <dt>[<a name="Pelzer1999" href="#Pelzer1999">Pelzer1999</a>]</dt>
      <dd>Gulutzan, Peter., Pelzer, Trudy.&nbsp; <i>SQL-99 Complete, Really:</i>                      
        An Example-Based Reference Manual of the New Standard.&nbsp; R&amp;D                      
        Books Miller Freeman (Lawrence KS: 1999).&nbsp;&nbsp; ISBN 0-87930-568-1                      
        pbk + CD-ROM.&nbsp; See [<a href="infoware.htm#Gulutzan1999">Gulutzan1999</a>]                
        in <a href="infoware.htm">Information Processing</a>.<br>                    
        &nbsp;&nbsp;&nbsp;</dd>
      <dt>[<a name="Perlis1961" href="#Perlis1961">Perlis1961</a>]</dt>
		<dd>Evans, A., Perlis, A.J., Van Zoeren, H.&nbsp; The Use of Threaded 
		Lists in Construction of a Combined ALGOL and Machine-Like Assembly 
		Processor.&nbsp; <i>Comm. ACM </i><b>4</b>, 1 (Jan. 1961), 36-41.&nbsp; 
		DOR &lt;<a href="https://dl.acm.org/doi/10.1145/366062.366081">https://dl.acm.org/doi/10.1145/366062.366081</a>&gt;.&nbsp; 
		See [<a href="#Evans1961">Evans1961</a>].<br>
&nbsp;&nbsp; </dd>
		<dt>[<a name="Ramm2002" href="#Ramm2002">Ramm2002</a>]</dt>
      <dd>Biermann, Alan W., Ramm, Dietolf.&nbsp; <i>Great Ideas in Computer                                
        Science with Java</i>.&nbsp; MIT Press (Cambridge, MA: 2002).&nbsp; ISBN                                
        0-262-02497-7 pbk. alk. paper.&nbsp; See [<a href="#[Biermann2002]">Biermann2002</a>]<br>                               
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</dd>
      <dt>[<a name="Ross2003" target="_top" href="#Ross2003">Ross2003</a>]</dt>
      <dd>Kurose, James F., Ross, Keith W.&nbsp; <i>Computer Networking: A         
        Top-Down Approach Featuring the Internet</i>.&nbsp; ed.2,         
        International.&nbsp; Addison-Wesley (Boston, MA: 2003).&nbsp; ISBN         
        0-321-17644-8 pbk.&nbsp; See [<a href="#Kurose2003">Kurose2003</a>]<br>        
        &nbsp;&nbsp;&nbsp;</dd>
      <dt>[<a name="Sattley1964" href="#Sattley1964">Sattley1964</a>]</dt>
		<dd>Cheatham, T. E. Jr., Sattley, Kirk.&nbsp; Syntax-Directed Compiling.&nbsp; 
		Proceedings of the April 21-23 1964 Spring Joint Computer Conference (AFIPS: 
		April 1964), 31-57.&nbsp; See [<a href="#Cheatham1964">Cheatham1964</a>].<br>&nbsp;&nbsp;</dd>
      	<dt>[<a name="Scott1977" href="#Scott1977">Scott1977</a>]</dt>
		<dd>Scott, Dana S.&nbsp; Logic and Programming Languages.&nbsp; 1976 ACM 
		Turing Award Lecture.&nbsp; <i>Comm. ACM </i><b>20</b>, 9 (September 
		1977), 634-641.&nbsp; PDF available at &lt;<a href="http://delivery.acm.org/10.1145/1290000/1283932/a1976-scott.pdf">http://delivery.acm.org/10.1145/1290000/1283932/a1976-scott.pdf</a>&gt;.<br>
&nbsp;&nbsp; <font size="2">The discussion on semantic structures and function 
		space is avauable collateral on the use of monotonicity and continuity 
		in [<a href="#Scott1993">Scott1993</a>].</font><br>
&nbsp;&nbsp; </dd>
		<dt>[<a name="Scott1993" href="#Scott1993">Scott1993</a>]</dt>
		<dd>Scott, Dana S.&nbsp; A Type-Theoretic Alternative to ISWIM, CUCH, 
		OWHY.&nbsp; <i>Theoretical Computer Science </i><b>121</b>, 12 (December 
		1993), 411-440.&nbsp; Available at &lt;<a href="https://www.sciencedirect.com/science/article/pii/030439759390095B">https://www.sciencedirect.com/science/article/pii/030439759390095B</a>&gt;.&nbsp;
		<br>
&nbsp;&nbsp; <font size="2">This paper was originally circulated informally in 
		1969, providing a type-theoretic approach that treats types as definite 
		and distinguished.</font><br>
&nbsp;&nbsp; </dd>
		<dt>[<a name="Scott2012" href="#Scott2012">Scott2012</a>]</dt>
		<dd>Scott, Dana S.&nbsp; <font SIZE="3">Œª-Calculus Then &amp; Now.&nbsp; 
		Presented at the ACM Turing Centenary Celebration, San Francisco, June 
		15-16, 2012.&nbsp; Annotated slides PDF version of 2012-08-25 available 
		at &lt;<a href="http://logic.berkeley.edu/colloquium/ScottACMTuring.pdf">http://logic.berkeley.edu/colloquium/ScottACMTuring.pdf</a>&gt;.&nbsp; 
		Video of the presentation available at &lt;<a href="https://doi.org/10.1145/2322176.2322185">https://doi.org/10.1145/2322176.2322185</a>&gt;.<br>
&nbsp;&nbsp; </font></dd>


<dt>[<a name="Sedgewick1989" target="_top" href="#Sedgewick1989">Sedgewick1989</a>]</dt>        
      <dd>Sedgewick, Robert.&nbsp; <i>Algorithms</i>.&nbsp; Second                                                       
        edition.&nbsp; Addison-Wesley (Reading, MA: 1983, 1988).&nbsp; 1989                                                       
        reprint with authors corrections.&nbsp; ISBN 0-201-06673-4.<font size="-1"><br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp; &quot;This book is intended to survey the most                                                       
        important computer algorithms in use today and to teach fundamental                                                       
        techniques to the growing number of people in need of knowing                                                       
        them.&nbsp; ... The broad perspective taken in the book makes it an                                                       
        appropriate introduction to the field.&quot; -- from the Preface, p.<i>v</i>.</font></dd>                                                       
      <dd><font size="-1">&nbsp;&nbsp;&nbsp;&nbsp; &quot;The orientation of the                                                       
        book is toward algorithms likely to be of practical use.&nbsp; ... Full                                                       
        implementations of the methods discussed (in an actual programming                                                       
        language) are included in the text, along with descriptions of the                                                       
        operations of these programs on a consistent set of examples.<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp; &quot;Properties of the algorithms and                                                       
        situations in which they might be useful are discussed in detail.&nbsp;                                                       
        Though not emphasized, connections to the analysis of algorithms and                                                       
        theoretical computer science are not ignored.&nbsp; When appropriate,                                                       
        empirical and analytical results are discussed to illustrate why certain                                                       
        algorithms are preferred.&nbsp; When interesting, the relationship of                                                       
        the practical algorithms being discussed to purely theoretical results                                                       
        is described.&quot;&nbsp; -- from the Preface, p.<i>vii</i>.<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp; &quot;To learn an algorithm well, one must                                                       
        implement and run it.&nbsp; Accordingly, the recommended strategy for                                                       
        understanding the programs present in this book is to implement and test                                                       
        them, experiment with variants, and try them out on real problems.&nbsp;                                                       
        We will use the Pascal programming language to discuss and implement                                                       
        most of the algorithms; since, however, we use a relatively small subset                                                       
        of the language, our programs can easily be translated into many other                                                       
        modern programming languages.&quot; -- from the Introduction, p.3.<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp; There is more discussion of my concerns about                                
        the actual execution of this approach under &quot;<a href="2001/r010101.htm">Do                                                       
        Programs Teach Algorithms?</a>&quot; -- dh.<br>                                                   
        &nbsp;&nbsp; Contents<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Preface</i><br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Fundamentals</i><br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1. Introduction<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2. Pascal<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3. Elementary                                                       
        Data Structures<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4. Trees<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5. Recursion<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6. Analysis of                                                       
        Algorithms<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7. Implementation                                                       
        of Algorithms<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Sorting Algorithms</i><br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8. Elementary                                                       
        Sorting Methods<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 9. Quicksort<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10. Radix Sorting<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 11. Priority                                                       
        Queues<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12. Mergesort<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 13. External                                                       
        Sorting<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Searching Algorithms</i><br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 14. Elementary                                                       
        Searching Algorithms<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 15. Balanced                                                       
        Trees<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16. Hashing<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 17. Radix                                                       
        Searching<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 18. External                                                       
        Searching<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp; <i>String Processing</i><br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 19. String                                                       
        Searching<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20. Pattern                                                       
        Matching<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 21. Parsing<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 22. File                                                       
        Compression<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 23. Cryptology<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Geometric Algorithms</i><br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 24. Elementary                                                       
        Geometric Methods<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 25. Finding the                                                       
        Convex Hull<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 26. Range                                                       
        Searching<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 27. Geometric                                                       
        Intersection<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 28. Closet-Point                                                       
        Problems<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Graph Algorithms</i><br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 29. Elementary                                                       
        Graph Algorithms<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 30. Connectivity<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 31. Weighted                                                       
        Graphs<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32. Directed                                                       
        Graphs<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 33. Network Flow<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 34. Matching<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Mathematical Algorithms</i><br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 35. Random                                                       
        Numbers<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 36. Arithmetic<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 37. Gaussian                                                       
        Elimination<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 38. Curve Fitting<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 39. Integration<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Advanced Topics</i><br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 40. Parallel                                                       
        Algorithms<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 41. The Fast                                                       
        Fourier Transform<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 42. Dynamic                                                       
        Programming<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 43. Linear                                                       
        Programming<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 44. Exhaustive                                                       
        Search<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 45. NP-Complete                                                       
        Problems<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Index</i><br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font></dd>                    
      <dt>[<a name="Skiena1998" target="_top" href="#[Skiena1998]">Skiena1998</a>]</dt>                    
      <dd>Skiena, Steven S.&nbsp; <i>The Algorithm Design Manual</i>.&nbsp;                                                       
        Springer-Verlag TELOS (New York: 1998).&nbsp; ISBN 0-387-94860-0 (book                                                       
        &amp; CD-ROM).<br>                                                       
        <font size="-1">                    
        &nbsp;&nbsp; Contents<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Preface<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp; I. Techniques<br>                    
        </i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.                                                       
        Introduction to Algorithms<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2. Data                                                       
        Structures and Sorting<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3. Breaking                                                       
        Problems Down<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4. Graph                                                       
        Algorithms<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5. Combinatorial                                                       
        Search and Heuristic Methods<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6. Intractable                                                       
        Problems and Approximations<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7. How to Design                                                       
        Algorithms<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp; <i>II. Resources</i><br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8. A Catalog of                                                       
        Algorithmic Problems<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 9. Algorithmic                                                       
        Resources<br>                    
        &nbsp;&nbsp;&nbsp;&nbsp; <i>Bibliography<br>                                                       
        &nbsp;&nbsp;&nbsp;&nbsp; Index<br>
&nbsp;&nbsp;&nbsp; </i></font></dd>
		<dt>[<a name="Steele1990" href="#Steele1990">Steele1990</a>]</dt>
		<dd>Steele, Guy L. Jr., White, Jon L.&nbsp; How to print floating-point 
		numbers accurately.&nbsp; <i>PLDI&#39;90 Proceedings of the ACM SIGPLAN 1990 
		conference on Programming Language Design and Implementation</i>.&nbsp; 
		June 1990, pp. 112-126 &lt;<a href="https://doi.org/10.1145/93542.93559">doi:10.1145/93542.93559</a>&gt;<br>
&nbsp;&nbsp; From the abstract: &quot;We present algorithms for accurately converting 
		floating-point numbers to decimal representation. ... No information is 
		lost ... . No &#39;garbage digits&#39; are produced.&nbsp; The output is 
		correctly rounded.&quot;&nbsp; <br>
&nbsp;&nbsp; This paper is in the vein of [<a href="#Matula1968">Matula1968</a>], 
		handling the output case by producing no more digits than necessary.</dd>
		<dd>&nbsp;&nbsp;&nbsp; </dd>
		<dt>[<a name="Strong1979" href="#Strong1979">Strong1979</a>]</dt>
		<dd>Fagin, Ronald., Nievergelt, Jurg., Strong, H. Raymond.&nbsp; 
		Extendible Hashing -- A Fast Access Method for Dynamic Files.&nbsp; <i>
		ACM Transactions on Database Systems <b>4</b></i>, 3 (September 1979), 
		315-344.&nbsp; See [<a href="#Fagan1979">Fagan1979</a>]</dd>
		<dt>&nbsp;&nbsp; </dt>
		<dt>[<a name="Sturgis1970" href="#Sturgis1970">Sturgis1970</a>]</dt>
		<dd>Earley, Jay., Sturgis, Howard. A Formalism for Translator 
		Interactions.&nbsp; <i>Comm. ACM <b>13</b></i>, 10 (October 1970), 
		607-617.&nbsp; See [<a href="#Earley1970">Earley1970</a>]</dd>
		<dt>&nbsp;</dt>
      <dt>[<a name="VanZoeren1961" href="#VanZoeren1961">VanZoeren1961</a>]</dt>
		<dd>Evans, A., Perlis, A.J., Van Zoeren, H.&nbsp; The Use of Threaded 
		Lists in Construction of a Combined ALGOL and Machine-Like Assembly 
		Processor.&nbsp; <i>Comm. ACM </i><b>4</b>, 1 (Jan. 1961), 36-41.&nbsp; 
		DOR &lt;<a href="https://dl.acm.org/doi/10.1145/366062.366081">https://dl.acm.org/doi/10.1145/366062.366081</a>&gt;.&nbsp; 
		See [<a href="#Evans1961">Evans1961</a>].<br>
&nbsp;&nbsp; </dd>
		<dt>[<a name="White1990" href="#White1990">White1990</a>]</dt>
		<dd>Steele, Guy L. Jr., White, Jon L.&nbsp; How to print floating-point 
		numbers accurately.&nbsp; <i>PLDI&#39;90 Proceedings of the ACM SIGPLAN 1990 
		conference on Programming Language Design and Implementation</i>.&nbsp; 
		June 1990, pp. 112-126.&nbsp; See [<a href="#Steele1990">Steele1990</a>]</dd>
		<dt>&nbsp;</dt>

    </dl>                               
                    
<div align="center">
	<!--webbot bot="Include" U-Include="../construction/2007/11/c071101d3.htm" TAG="BODY" startspan -->
		<table border="3" width="80%" align="center" bordercolor="#006600" id="table1">
			<tr>
				<td valign="middle" align="center"><small>
					<p><b><font color="#006600">
					The Content Material here was successfully 
					repurposed/preserved/repaved as part 
					of the
					<a href="../construction/2007/11/c071101d.htm"><font color="#006600">2023-08-29</font></a> 
					stage of the 
					</font><font color="#800000">
					<a href="../construction/2007/11/c071101.htm"><font color="#006600">Site 
					Preservation 
					Project</font></a></font><font color="#006600">.&nbsp; Check 
					those pages for additional details of the approach to 
					repurposing/preservation and correction.</font> </b></p></small>
				</td>
			</tr>
			<!-- Included from orcmid.github.io/construction/2007/11/c071101d3.htm of 2023-12-04T21:26Z -->
		</table>
	<!--webbot bot="Include" i-checksum="19579" endspan --></div>

<table border="0" cellspacing="3" width="100%">
  <tr>
    <td width="29%"><a href="index.htm" target="_top">
	<img border="0" src="../images/hardhat-thumb.gif" alt="Hard Hat Area" width="80" height="60"></a></td>
    <td width="34%" valign="middle" align="center">
	<!--webbot bot="Include"
      U-Include="../construction/templates/00/c000005d.htm" TAG="BODY" startspan -->
<font face="Arial, Microsoft Sans Serif, Helvetica, Geneva, Swiss, Sans Serif">
<small><!-- Included from orcmid.github.io/construction/templates/00/c000005c.htm
                of 2023-09-02T00:20Z -->
<small>You are navigating <a rel="nofollow" href="../" target="_top">Orcmid on GitHub</a></small></small></font>
<!--webbot bot="Include" i-checksum="52288" endspan --></td>
    <td width="37%">
      <p align="right"><font size="-2">created 2000-07-18-18:06 -0700 (pdt) by
		<a target="_top" href="../orcmid">orcmid</a></font></p>
    </td>
  </tr>
</table>

</body>                    
</html>                    
